{"version":3,"sources":["src/js/components/util.js","src/js/app.js","src/js/components/event.js","src/js/components/ele-dev.js","src/js/components/dom.js"],"names":["assign","Object","keys","isArray","Array","_log","args","forEach","v","console","log","_capital","val","toUpperCase","slice","_is","type","_isInst","ctor","obj","_type","el","Element","Document","arrlike","len","length","num","isNaN","usable","class","_method","_class","not","doc","def","undef","win","window","bool","fn","str","nul","inst","arr","_fnval","ctxt","prototype","apply","STRIP_COMMENTS","ARGUMENT_NAMES","_argNames","fnStr","toString","replace","result","indexOf","match","stripped","i","push","_matches","ele","sel","matchSel","matches","msMatchesSelector","webkitMatchesSelector","call","_event","constructor","this","_events","_emit","_preEvent","evt","_eventApp","callback","scope","event","on","$EvtApp","$evt","split","key","off","_off","_Evt","app","splice","undefined","once","$Fn","emit","$Evt","$args","includes","_evt","listeners","map","listenerValues","clear","_eventCount","clearListeners","_names","add","bind","remove","unbind","fire","trigger","callbacks","passive","opts","noop","defineProperty","get","capture","addEventListener","removeEventListener","tagRE","tagExpandRE","_qsa","dom","document","classes","test","charAt","getElementById","substr","getElementsByClassName","getElementsByTagName","querySelectorAll","_createElem","html","container","createElement","innerHTML","childNodes","removeChild","_elem","trim","NodeList","filter","item","ready","ele$1","super","_newEvts","delegate","$super","useCapture","e","target","readyState","attachEvent","_el","idx","toArray","first","_concat","concat","_map","each","every","_contains","parent","node","contains","parentNode","traverseDF","_node","recurse","after","prepend","before","append","insertAfter","insertBefore","appendTo","prependTo","reduce","acc","inside","clone","nodes","arg","nodeType","parentInDoc","documentElement","next","nextSibling","firstChild","cloneNode","nodeName","src","ownerDocument","defaultView","eval","_cssNumber","_maybeAddPx","name","style","prop","css","getComputedStyle","getPropertyValue","props","computedStyle","_prop","removeProperty","cssText","width","height","sz","value","_offset","offset","$el","coords","$this","_coords","parentOffset","offsetParent","top","left","position","getBoundingClientRect","pageXOffset","pageYOffset","Math","round","classcache","getclass","className","svg","baseVal","_classRE","RegExp","hasClass","some","addClass","classList","cls","_name","join","removeClass","toggleClass","when","body","onready","onload","onblur","onfocus","onfocusin","onfocusout","onresize","onclick","onscroll","ondblclick","onmousedown","onmouseup","onmousemove","onmouseover","onmouseout","onmouseenter","onmouseleave","onchange","onselect","onsubmit","onkeydown","onkeypress","onkeyup","oncontextmenu","onhover","fnOver","fnOut","_navbar","preventDefault","_img","nav","img"],"mappings":"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","file":"../js/app.modern.min.js","sourcesContent":["// export const { assign, keys, values } = Object;\n// export let { isArray, from, of } = Array;\nexport const assign = Object.assign;\nexport const values = Object.values;\nexport const keys = Object.keys;\n\nexport const isArray = Array.isArray;\nexport const from = Array.from;\nexport const of = Array.of;\n\n// Remove certain properties\nexport let _removeProps = (prop, obj) => {\n    let newObj = assign({}, obj);\n    prop.forEach(key => delete newObj[key]);\n    return newObj;\n };\n\n// Create an array of values that two array share in common\nexport let _intersect = (a, b) => a.filter(val => b.includes(val));\n\n// Log values\nexport let _log = (...args) => args.forEach(v => console.log(v));\n\n// Capitalize strings\nexport let _capital = val => val[0].toUpperCase() + val.slice(1);\n\n// Test the type of a value\nexport let _is = (val, type) => (typeof val === type);\n\n// Is Instance Of\nlet _isInst = (ctor, obj) => (ctor instanceof obj);\nlet _type = type => { // Tweak of _is\n    return val => _is(val, type);\n};\n\nassign(_is, {\n    el: el => _isInst(el, Element) || _isInst(el, Document),\n    arrlike (obj) {\n        let len = _is(obj.length, \"number\") && obj.length;\n        return len === 0 || len > 0 && (len - 1) in obj;\n    },\n    num: val => !isNaN(val) && _type(\"number\") (val),\n    usable: v => !_is(v, \"undefined\") && v !== null,\n    class: obj => obj && obj._method && obj._class,\n    not: (type, ...args) => !_is[type](...args),\n    doc: ctor => _isInst(ctor, Document),\n    def: v => !_is(v, \"undefined\"),\n    undef: _type(\"undefined\"),\n    win: v => v && v.window,\n    bool: _type(\"boolean\"),\n    fn: _type(\"function\"),\n    str: _type(\"string\"),\n    obj: _type(\"object\"),\n    nul: v => v === null,\n    inst: _isInst,\n    arr: isArray,\n    _type\n});\n\n/**\n * @param  {Function} fn\n * @param  {Array<any>} args\n * @param  {Object} ctxt\n */\nexport let _fnval = (fn, args, ctxt) => {\n    if (!_is.fn(fn) ||\n        keys(fn.prototype || {}).length > 0)\n        { return fn; }\n    return fn.apply(ctxt, args);\n};\n\nlet STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nlet ARGUMENT_NAMES = /(?:^|,)\\s*([^\\s,=]+)/g;\n\n// Argument names\nexport let _argNames = fn => {\n    let fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n    let argsList = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')'));\n    let result = argsList.match( ARGUMENT_NAMES ), stripped = [];\n\n    if (_is.nul(result)) return [];\n    else {\n        for (let i = 0; i < result.length; i ++) {\n            stripped.push( result[i].replace(/[\\s,]/g, '') );\n        }\n\n        return stripped;\n    }\n};\n\n// Get or set a value in an Object, based on it's path\nexport let _path = (obj, path, val) => {\n    path = path.toString().split(/[.,]/g);\n    if (_is.def(val)) {\n        if (path.length > 1) {\n            _path(obj[path.shift()], path, val);\n        } else { obj[path[0]] = val; }\n        return val;\n    } else {\n        path.forEach(_val => { obj = obj[_val]; });\n    }\n    return obj;\n};\n\n/*\n    Builds on path and adds more power,\n    * Allows for multiple paths one value\n    * Using Objects as paths and setting the values individually\n    * Access values as an Array, from multiple paths\n*/\nexport let _attr = (obj, path, val) => {\n    if (_is.obj(path) && !_is.arr(path))\n        { return assign(obj, path); }\n    else if (_is.arr(path)) {\n        if (_is.undef(val)) {\n            return path.map(_key => _path(obj, _key));\n        } else {\n            path.forEach(_key => { _path(obj, _key, val); });\n        }\n    } else { return _path(obj, path, val); }\n    return obj;\n};\n\n// The matches() method checks to see if the Element would be selected by the provided selectorString -- in other words -- checks if the element \"is\" the selector.\nexport let _matches = (ele, sel) => {\n    if (_is.undef(ele)) return;\n    let matchSel = ele.matches || ele.msMatchesSelector || ele.webkitMatchesSelector;\n    if (matchSel) return matchSel.call(ele, sel);\n};\n\n// A more efficient `new` keyword that allows for arrays to be passed as arguments\nexport let _new = function (ctor, args) {\n    let F = function () { return ctor.apply(this, args); };\n    F.prototype = ctor.prototype;\n    return new F();\n};\n\nexport default { _matches, _capital, _is, _intersect, _fnval, _argNames, _path, _attr, _new, assign, keys, values, from, of, _log };\n","// import swup from \"swup\";\n// import { el } from \"./components/ele\";\nimport { _log } from \"./components/util\";\n// import preload from '@swup/preload-plugin';\n// import scrollPlugin from \"@swup/scroll-plugin\";\n// import { _global, _body } from \"./components/global\";\n// import { _is } from \"./components/util\";\n// import anime from 'animejs';\nimport el, { onclick, toggleClass } from \"./components/dom\";\n// onclick,\ntry {\n    let _navbar = el('.navbar');\n    onclick(_navbar, '.navbar-menu', e => {\n        e.preventDefault();\n        toggleClass(_navbar, \"navbar-show\");\n        console.log(\"Navbar-show\");\n    });\n    // let _backToTop = el('#back-to-top');\n\n    // let _height = _navbar.height();\n    // let _focusPt = _height + 20;\n    // let _load, _scroll, _scrollEle = _body.get(0);\n    /*\n    // _scrollEle = window.document.scrollingElement || window.document.body || window.document.documentElement;\n    // _scrollEle = el(_scrollEle);\n    _navbar.click('.navbar-menu', e => {\n        e.preventDefault();\n        _navbar.toggleClass(\"navbar-show\");\n    });\n\n    _backToTop.click(e => {\n        e.preventDefault();\n        anime({\n            targets: _scrollEle,\n            scrollTop: 0,\n            duration: 500,\n            easing: 'easeInOutQuad'\n        });\n    });\n\n    let actioncenter = el(\".layer-action-center\");\n    _global.scroll(_scroll = () => {\n        _navbar.toggleClass(\"navbar-focus\", (_global.scrollTop() + _height) >= _focusPt);\n        _navbar.hasClass(\"navbar-show\") && _navbar.removeClass(\"navbar-show\");\n\n        if ((_global.scrollTop() + _height) >= _focusPt * 2) {\n            actioncenter.show();\n        } else { actioncenter.hide(); }\n    });\n\n\n    _load = () => {\n        let _next_layer_btn = el(\".next-layer\"), _next_layer;\n        let _img = el(\".load-img\");\n        let _main = el(\".main\");\n\n        _scroll();\n\n        var body = document.body,\n            html = document.documentElement;\n\n        var height = Math.max( body.scrollHeight, body.offsetHeight,\n                            html.clientHeight, html.scrollHeight, html.offsetHeight );\n\n        if (height <= window.innerHeight) {\n            actioncenter.show();\n        }\n\n        _img.each($img => {\n            let img = el($img);\n            let _core_img = img.find(\".core-img\").get(0);\n            let _placeholder_img = img.find(\".placeholder-img\");\n\n            if (_is.def(_core_img)) {\n                if (_core_img.complete) {\n                    _placeholder_img.addClass(\"core-img-show\");\n                } else {\n                    _core_img.addEventListener(\"load\", function () {\n                        _placeholder_img.addClass(\"core-img-show\");\n\n                        setTimeout(function () { _placeholder_img.hide(); }, 3000);\n                    }, false);\n                }\n            }\n        });\n\n        _next_layer_btn.click((e, _el) => {\n            e.preventDefault();\n            _next_layer = el(_el).closest(\".layer\", _main).next(\".layer\");\n            anime({\n                targets: _scrollEle,\n                scrollTop: el(_next_layer).offset().top - _height,\n                duration: 500,\n                easing: 'easeInOutQuad'\n            });\n        });\n\n        // let options = {\n        //     root: null,\n        //     rootMargin: '0px',\n        //     threshold: 0,\n        //     // threshold: Array.from(Array(101), (_, x) => x / 100)\n        // };\n\n        // let observer = new IntersectionObserver(entries => {\n        //     entries.forEach((entry, i) => {\n        //         // if (entry.isIntersecting) {\n        //         if (entry.intersectionRatio > 0) {\n        //             // this.onScreen(entry)\n\n        //             anime({\n        //                 targets: entry.target,\n        //                 translateY: 0,\n        //                 opacity: 1,\n        //                 duration: 1000,\n        //                 easing: 'easeInOutExpo',\n        //                 delay: i * 500,\n        //                 begin() {\n        //                     observer.unobserve(entry.target);\n        //                 }\n        //             });\n        //         } else {\n        //             // this.offScreen(entry)\n        //         }\n        //         // }\n        //     });\n        // }, options);\n\n        // el(\".layer\").forEach(_el => {\n        //     observer.observe(_el);\n        // });\n    };\n\n    _load();\n    new swup({\n        requestHeaders: {\n            \"X-Requested-With\": \"swup\", // So we can tell request comes from swup\n            \"x-partial\": \"swup\" // Request a partial html page\n        },\n        plugins: [new scrollPlugin({\n            doScrollingRightAway: false,\n            animateScroll: true,\n            scrollFriction: 0.3,\n            scrollAcceleration: 0.04,\n        })] // new preload(),\n    })\n\n    // This event runs for every page view after initial load\n    .on('contentReplaced', _load); */\n} catch (e) {\n    let _img = [...document.getElementsByClassName(\"placeholder-img\")];\n    let _navbar = [...document.getElementsByClassName(\"navbar\")];\n    _navbar.forEach(function (nav) {\n        nav.classList.add(\"navbar-focus\");\n    });\n    _img.forEach(function (img) {\n        img.classList.add(\"core-img-show\");\n    });\n}","import { _is, keys, _argNames } from \"./util\";\n\n// A small event emitter\nexport default class _event {\n    constructor() {\n        this._events = {}; // Event info.\n        this._emit = [];  // Store events set to be emitted\n    }\n\n    // Prepare the event\n    _preEvent(evt) {\n        if (!this._events[evt]) // List of event's\n            { this._events[evt] = []; }\n        return this._events[evt];\n    }\n\n    // Apply event as object\n    _eventApp(callback, scope, event) {\n        return {\n            callback: callback,\n            scope: scope,\n            event: event\n        };\n    }\n\n    // Add a listener for a given event\n    on(evt, callback, scope) {\n        let $EvtApp, $evt;\n        if (_is.undef(evt)) { return; } // If there is no event break\n        if (_is.str(evt)) { evt = evt.split(/\\s/g); }\n        if (!_is.arr(evt) && !_is.obj(evt)) { evt = [evt]; } // Set evt to an array\n\n        // Loop through the list of events\n        keys(evt).forEach(function (key) {\n            $evt = evt[key];\n            if (_is.obj(evt) && !_is.arr(evt)) {\n                $EvtApp = this._eventApp($evt, callback || this, key);\n                this._preEvent(key).push($EvtApp); // Set event list\n            } else {\n                $EvtApp = this._eventApp(callback, scope, $evt);\n                this._preEvent($evt).push($EvtApp); // Set event list\n            }\n        }, this);\n        return this;\n    }\n\n    // Removes a listener for a given event\n    off(evt, callback, scope) {\n        let $evt;\n        if (_is.undef(evt)) { return; } // If there is no event break\n        if (_is.str(evt)) { evt = evt.split(/\\s/g); }\n        if (!_is.arr(evt) && !_is.obj(evt)) { evt = [evt]; } // Set evt to an array\n\n        let _off = function ($evt, callback, scope) {\n            let _Evt = this._preEvent($evt);\n\n            if (callback) {\n                let i = 0, val, app = this._eventApp(callback, scope, $evt);\n                for (; i < _Evt.length; i ++) {\n                    val = _Evt[i];\n                    if (val.callback === app.callback &&\n                         val.scope === app.scope)\n                         { break; }\n                }\n\n                _Evt.splice(i, 1);\n            } else { this._events[$evt] = undefined; }\n        };\n\n        keys(evt).forEach(function (key) {\n            $evt = evt[key];\n            if (_is.obj(evt) && !_is.obj(evt)) {\n                _off.call(this, key, $evt, scope);\n            } else { _off.call(this, $evt, callback, scope); }\n        }, this);\n        return this;\n    }\n\n    // Adds a one time event listener for a given event\n    once(evt, callback, scope) {\n        if (_is.undef(evt)) { return; } // If there is no event break\n        if (_is.str(evt)) { evt = evt.split(/\\s/g); }\n        if (!_is.arr(evt) && !_is.obj(evt)) { evt = [evt]; } // Set evt to an array\n\n        let $Fn = function (...args) {\n            this.off(evt, $Fn, scope);\n            callback.apply(scope, args);\n        };\n\n        this.on(evt, $Fn, scope);\n        return this;\n    }\n\n    // Call all function(s) within an event\n    emit(evt, args, scope) {\n        let $Evt, $args = args;\n        if (_is.undef(evt)) { return; } // If there is no event break\n        if (_is.str(evt)) { evt = evt.split(/\\s/g); }\n        if (!_is.arr(evt)) { evt = [evt]; } // Set evt to an array\n\n        // Loop through the list of events\n        evt.forEach(function ($evt) {\n            $Evt = this._preEvent($evt);\n            if (!this._emit.includes($evt))\n                { this._emit.push($evt); }\n\n            $Evt.forEach(_evt => {\n                $args = args;\n                // Check to see if first param is $evt, if so give details about event\n                if (_argNames(_evt.callback)[0] === \"$evt\")\n                    { $args = [_evt, ...args]; }\n\n                _evt.callback\n                    .apply(_is.undef(_evt.scope) ? scope : _evt.scope, $args);\n            }, this);\n        }, this);\n        return this;\n    }\n\n    // List's all listeners for a given event\n    listeners(evt) {\n        let $Evt = this._preEvent(evt);\n        if (!$Evt.length) { return []; }\n        return $Evt.map(val => val.callback);\n    }\n\n    // List's all listener values for a given event\n    listenerValues(evt, ...args) {\n        let $Evt = this._preEvent(evt);\n        if (!$Evt.length) { return []; }\n        return $Evt.map(val => val.callback.call(val.scope, ...args));\n    }\n\n    // Clear all events\n    clear()\n        { this._eventCount = 0; this._events = {}; return this; }\n\n    // Clear all events\n    clearListeners(evt)\n        { this._events[evt] = []; return this; }\n\n    // Name of all event's\n    get _names() { return Object.keys(this._events); }\n\n    // Number of events\n    get _eventCount() { return this._names.length; }\n\n    // Alias for the `on` method\n    add(...args) { return this.on(...args); }\n    bind(...args) { return this.on(...args); }\n\n    // Alias for the `off` method\n    remove(...args) { return this.off(...args); }\n    unbind(...args) { return this.off(...args); }\n\n    // Alias for the `emit` method\n    fire(...args) { return this.emit(...args); }\n    trigger(...args) { return this.emit(...args); }\n\n    // Alias for the `listeners` method\n    callbacks(...args) { return this.listeners(...args); }\n}","import { _matches, _is, keys, _log } from \"./util\";\nimport _event from './event';\n\n// Test for passive support, based on [github.com/rafrex/detect-passive-events]\nlet passive = false, opts = {}, noop = () => { };\nopts = Object.defineProperty({}, \"passive\", {\n\tget: () => passive = { capture: false, passive: true }\n});\n\nwindow.addEventListener(\"PassiveEventTest\", noop, opts);\nwindow.removeEventListener(\"PassiveEventsTest\", noop, opts);\n\nlet ele;\nlet tagRE = /^\\s*<(\\w+|!)[^>]*>/;\nlet tagExpandRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig;\nexport let _qsa = (dom = document, sel) => {\n    let classes;\n    if (!_is.str(sel) && sel.length === 0) return [];\n    if (/^(#?[\\w-]+|\\.[\\w-.]+)$/.test(sel)) {\n        switch (sel.charAt(0)) {\n            case '#':\n                return [dom.getElementById(sel.substr(1))];\n            case '.':\n                classes = sel.substr(1).replace(/\\./g, ' ');\n                return [...dom.getElementsByClassName(classes)];\n            default:\n                return [...dom.getElementsByTagName(sel)];\n        }\n    }\n\n    return [...dom.querySelectorAll(sel)];\n};\n\n// Create an Element List from a HTML string\nexport let _createElem = html => {\n    let dom, container;\n    container = document.createElement('div');\n    container.innerHTML = '' + html.replace(tagExpandRE, \"<$1></$2>\");\n    dom = [].slice.call(container.childNodes);\n    dom.forEach(el => {\n        container.removeChild(el);\n    });\n\n    return dom;\n};\n\n// Element selector\nexport let _elem = (sel, ctxt) => {\n    if (_is.str(sel)) {\n        sel = sel.trim();\n        if (tagRE.test(sel)) { return _createElem(sel); }\n        else { return _qsa(ctxt, sel); }\n    } else if (_is.inst(sel, ele)) { return sel; }\n    else if (_is.arr(sel) || _is.inst(sel, NodeList))\n        { return [...sel].filter(item => _is.def(item)); }\n    else if (_is.obj(sel) || _is.el(sel)) { return [sel]; }\n    else if (_is.fn(sel)) { new ele(document).ready(sel); }\n    return [];\n};\n\n// Element Object [Based on Zepto.js]\nexport default ele = class extends _event {\n    constructor(sel = '', ctxt) {\n        super();\n        this.sel = sel; // Selector\n        this.ele = _elem(this.sel, ctxt); // Element\n\n        for (let i = 0; i < this.ele.length; i++) {\n            this[i] = this.ele[i];\n        }\n        this.length = this.ele.length;\n    }\n\n    on(evt, opts, callback) {\n        let _newEvts, _evt, delegate, $super = _event.prototype.on.bind(this);\n        if (_is.undef(evt)) { return; } // If there is no event break\n        if (_is.str(evt)) { evt = evt.split(/\\s/g); }\n        if (!_is.arr(evt) && !_is.obj(evt)) { evt = [evt]; } // Set evt to an array\n\n        _evt = (_is.obj(evt) && !_is.arr(evt) ? keys(evt) : evt);\n        _newEvts = _evt.filter(val => !(val in this._events), this);\n\n        if (_is.str(opts)) delegate = opts;\n        else callback = opts;\n\n        _log(delegate);\n\n        [].forEach.call(this, (el, i) => {\n            $super(evt, callback);\n            if (!(_newEvts.length > 0) && !_is.undef(el) && !_is.nul(el)) return;\n\n            let useCapture;\n            let _emit = evt => e => {\n                let target = _is.str(delegate) && _matches(e.target, delegate) ? e.target : el;\n                if (!_is.str(delegate) || _matches(e.target, delegate))\n                    this.emit(evt, [e, target, this, i], target);\n            };\n\n            if (/ready|load/.test(_newEvts)) {\n                if (!/in/.test(document.readyState)) { _emit(\"ready load\") (); }\n                else if (document.addEventListener) {\n                    document.addEventListener('DOMContentLoaded', _emit(\"ready load\"));\n                } else {\n                    // Support for IE\n                    document.attachEvent('onreadystatechange', e => {\n                        if (!/in/.test(document.readyState)) _emit(\"ready load\") (e);\n                    });\n                }\n            } else {\n                _newEvts.forEach(val => {\n                    useCapture = /blur|focus/.test(val);\n                    el.addEventListener(val, _emit(val), val === \"scroll\" ? passive : { useCapture });\n                });\n            }\n        });\n        return this;\n    }\n};\n","import { _matches, _is, _fnval, _capital } from \"./util\";\r\nimport ele, { _qsa, _elem, _createElem } from './ele-dev';\r\n\r\n// Quick access to a new ele object\r\nexport let el = (sel, ctxt) => {\r\n    return _is.inst(sel, ele) && !_is.usable(ctxt) ? sel : new ele(sel, ctxt);\r\n};\r\n\r\n// Select specific element at an index of the ele object\r\nexport let get = (_el, idx) => {\r\n    _el = el(_el);\r\n    return _is.undef(idx) ? [].slice.call(_el) : _el[idx >= 0 ? idx : idx + _el.length];\r\n};\r\nexport let nth = get;\r\nexport let toArray = val => (_is.inst(val, ele) ? get(val) : val); // Convert ele objects to arrays\r\nexport let indexOf = (_el, val) => [].indexOf.call(el(_el), val); // Array.indexOf for the ele object\r\n\r\n// Array.slice designed to work with Elements\r\nexport let slice = (_el, ...args) => el([].slice.apply(el(_el), args));\r\n\r\n// Create a wrapper ele object for an element at a certain index\r\nexport let eq = (_el, idx) => {\r\n    return idx === -1 ? slice(_el, idx) : slice(_el, idx, +idx + 1);\r\n};\r\n\r\n// Select the first element in ele object\r\nexport let first = _el => {\r\n    let el = get(_el, 0);\r\n    return el && !_is.obj(el) ? el : new ele(el);\r\n};\r\n\r\n// Select the last element in ele object\r\nexport let last = _el => {\r\n    let el = get(_el, -1);\r\n    return el && !_is.obj(el) ? el : new ele(el);\r\n};\r\n\r\n// Support the Element Object as an Array\r\nlet _concat = function (...args) {\r\n    [].map.call(args, val => toArray(val)); // Transform Elements to Arrays\r\n    return [].concat(...args);\r\n};\r\n\r\n// Map objects and remove undefined/null values\r\nlet _map = (obj, fn, ctxt) => {\r\n    let arr = [].map.call(obj, fn, ctxt)\r\n        .filter(item => _is.usable(item));\r\n\r\n    // Creates a flat Array of Objects\r\n    return (arr.length > 0 ? _concat(...arr) : arr);\r\n};\r\n\r\n// Added support for element mapping\r\nexport let map = (_el, fn) => {\r\n    _el = el(_el);\r\n    return el(_map(_el, (el, i) => fn.call(el, el, i)));\r\n};\r\n\r\n// Functions the same way Array.forEach does\r\nexport let forEach = (_el, fn, ctxt) => {\r\n    _el = el(_el);\r\n    [].forEach.call(_el, function (el, idx)\r\n        { fn.call(ctxt, el, idx); }, ctxt);\r\n    return _el;\r\n};\r\n\r\n/* Similar to forEach, however, the context of the iterator is set and\r\n   it allows the iterators return value to stop the iteration just like Array.every */\r\nexport let each = (_el, fn) => {\r\n    _el = el(_el);\r\n    [].every.call(_el, function (el, idx)\r\n        { return fn.call(el, el, idx) !== false; });\r\n    return _el;\r\n};\r\n\r\n// Quickly filter nodes by a selector\r\nexport let filter = (_el, sel) => {\r\n    _el = el(_el);\r\n    if (_is.undef(sel)) return _el;\r\n    return el([].filter.call(_el, _is.fn(sel) ? sel : ele => _matches(ele, sel), _el));\r\n};\r\n\r\n// Check if the parent node contains the given DOM node. Returns false if both are the same node.\r\nlet _contains = (parent, node) => {\r\n    if (parent.contains) return parent !== node && parent.contains(node);\r\n    while (node && (node = node.parentNode))\r\n        if (node === parent) return true;\r\n    return false;\r\n};\r\n\r\n// Find an element that matches a selector in a ele object\r\nexport let find = (_el, sel) => {\r\n    let result;\r\n    _el = el(_el);\r\n    if (!sel) result = el();\r\n    else if (_is.obj(sel)) {\r\n        result = filter(sel, el => {\r\n            return [].some.call(_el, parent => _contains(parent, el));\r\n        });\r\n    } else if (_el.length === 1) { result = el(_qsa(first(_el), sel)); }\r\n    else { result = map(_el, el => _qsa(el, sel)); }\r\n    return result;\r\n};\r\n\r\n// Check to see if a ele object has a certain element\r\nexport let has = (_el, sel) => {\r\n    return filter(_el, el => {\r\n        return _is.obj(sel) ? _contains(el, sel) : find(el, sel).length;\r\n    });\r\n};\r\n\r\n// Traverse upwards from the current element to find the first element that matches the selector.\r\nexport let closest = (_el, sel, ctxt) => {\r\n    let list = _is.obj(sel) && el(sel);\r\n    _el = el(el);\r\n    return el(\r\n        [].reduce.call(_el, (acc, $el) => {\r\n            do {\r\n                if (list ? indexOf(list, $el) >= 0 : _matches($el, sel)) break;\r\n                $el = $el !== ctxt && !_is.doc($el) && $el.parentNode;\r\n            } while ($el !== null && $el.nodeType === 1);\r\n            if ($el && acc.indexOf($el) < 0) acc.push($el);\r\n            return acc;\r\n        }, [])\r\n    );\r\n};\r\n\r\n// Select the parents of an element\r\nexport let parents = (_el, sel) => {\r\n    let ancestors = [], nodes = el(_el);\r\n    while (nodes.length > 0) {\r\n        nodes = map(nodes, el => {\r\n            if ((el = el.parentNode) && !_is.doc(el) && ancestors.indexOf(el) < 0) {\r\n                ancestors.push(el);\r\n                return el;\r\n            }\r\n        });\r\n    }\r\n    return filter(ancestors, sel);\r\n};\r\n\r\n// `pluck` based on underscore.js, select a specific property from the ele object\r\nexport let pluck = (_el, prop) => map(_el, el => el[prop]);\r\n\r\n// Select all the different values in an Array, based on underscorejs\r\nlet _uniq = arr => {\r\n    return [].filter.call(arr, (val, idx) => arr.indexOf(val) === idx);\r\n};\r\n\r\n// Get immediate parents of each element in the collection. If CSS selector is given, filter results to include only ones matching the selector.\r\nexport let parent = (_el, sel) => {\r\n    return filter(_uniq(pluck(_el, 'parentNode')), sel);\r\n};\r\n\r\n// Select all children of an element\r\nlet _children = val => {\r\n    return 'children' in val ? [].slice.call(val.children) :\r\n        _map(val.childNodes, node => {\r\n            if (node.nodeType === 1) return node;\r\n        });\r\n};\r\n\r\n// Get immediate children of each element in the current collection. If selector is given, filter the results to only include ones matching the CSS selector.\r\nexport let children = (_el, sel) => {\r\n    return filter(map(_el, el => _children(el)), sel);\r\n};\r\n\r\n// Get the children of each element in the collection, including text and comment nodes.\r\nexport let contents = _el => {\r\n    return map(_el, el => el.contentDocument || [].slice.call(el.childNodes));\r\n};\r\n\r\n// Get all sibling nodes of each element in the collection. If CSS selector is specified, filter the results to contain only elements that match the selector.\r\nexport let siblings = (_el, sel) => {\r\n    return filter(map(_el, el =>\r\n        [].filter.call(\r\n            _children(el.parentNode),\r\n            child => (child !== el)\r\n        )\r\n    ), sel);\r\n};\r\n\r\n/* - DOM Manipulation - */\r\n// Remove elements in the current collection from their parent nodes, effectively detaching them from the DOM.\r\nexport let remove = _el => {\r\n    return each(_el, el => {\r\n        if (_is.def(el.parentNode));\r\n            el.parentNode.removeChild(el);\r\n    });\r\n};\r\n\r\n// Traverse DOM Depth First\r\nlet traverseDF = (_node, fn) => {\r\n    let recurse;\r\n    // This is a recurse and immediately-invoking function\r\n    recurse = node => { // Step 2\r\n        node.childNodes && [...node.childNodes].forEach(recurse, node); // Step 3\r\n        fn.call(node, node); // Step 4\r\n    };\r\n    recurse(_node); // Step 1\r\n};\r\n\r\n// Generate the `after`, `prepend`, `before`, `append`, `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\r\nexport let { after, prepend, before, append, insertAfter, insertBefore, appendTo, prependTo } = [ 'after', 'prepend', 'before', 'append' ].reduce((acc, fn, idx) => {\r\n    let inside = idx % 2 //=> prepend, append\r\n    acc[fn] = function (_el, ...args) {\r\n        _el = el(el);\r\n        // Arguments can be nodes, arrays of nodes, Element objects and HTML strings\r\n        let clone = _el.length > 1;\r\n        let nodes = _map(args, arg => {\r\n            if (_is.arr(arg)) {\r\n                return arg.reduce((acc, el) => {\r\n                    if (_is.def(el.nodeType)) acc.push(el);\r\n                    else if (_is.inst(el, ele)) acc = acc.concat(toArray(el));\r\n                    else if (_is.str(el)) acc = acc.concat(_createElem(el));\r\n                    return acc;\r\n                }, []);\r\n            }\r\n\r\n            return _is.obj(arg) || _is.nul(arg) ? arg : _createElem(arg);\r\n        });\r\n\r\n        return each(_el, target => {\r\n            let parent = inside ? target : target.parentNode;\r\n            let parentInDoc = _contains(document.documentElement, parent);\r\n            let next = target.nextSibling, first = target.firstChild;\r\n\r\n            // Convert all methods to a \"before\" operation\r\n            target = [next, first, target, null] [idx];\r\n            nodes.forEach(node => {\r\n                if (clone) node = node.cloneNode(true);\r\n                else if (!parent) return remove(node);\r\n                parent.insertBefore(node, target);\r\n\r\n                if (parentInDoc) {\r\n                    traverseDF(node, function (el) {\r\n                        if (!_is.nul(el.nodeName) && el.nodeName.toUpperCase() === 'SCRIPT' &&\r\n                            (!el.type || el.type === 'text/javascript') && !el.src) {\r\n                            let target = el.ownerDocument ? el.ownerDocument.defaultView : window;\r\n                            target.eval.call(target, el.innerHTML);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    };\r\n\r\n    // after    => insertAfter, prepend  => prependTo\r\n    // before   => insertBefore, append   => appendTo\r\n    acc[inside ? `${fn}To` : `insert${_capital(fn)}`] = (_el, html) => {\r\n        _el = el(_el);\r\n        acc[fn](el(html), _el);\r\n        return _el;\r\n    };\r\n\r\n    return acc;\r\n}, {});\r\n\r\n// Replace each element in the collection–both its contents and the element itself–with the new content. Content can be of any type described in before.\r\nexport let replaceWith = (_el, content) => remove(before(_el, content));\r\nexport let clone = _el => map(_el, el => el.cloneNode(true)); // Duplicate all elements in the collection via deep clone.\r\n\r\n// CSS properties that use unitless numbers\r\nlet _cssNumber = [\"column-count\", \"columns\", \"font-weight\", \"line-height\", \"opacity\", \"z-index\", \"zoom\"];\r\n\r\n// Decide if the value deserves px at the\r\nlet _maybeAddPx = (name, val) => {\r\n    return _is.num(+val) && !_cssNumber.includes(name) ? `${val}px` : val;\r\n};\r\n\r\n// Read or set CSS properties on DOM elements.\r\nexport let style = (_el, ...args) => {\r\n    let [prop, val] = args, css = '', key;\r\n    if (args.length < 2) {\r\n        let el = first(_el);\r\n        if (!el) return;\r\n        if (_is.str(prop)) {\r\n            return el.style[prop] || window.getComputedStyle(el, '').getPropertyValue(prop);\r\n        } else if (_is.arr(prop)) {\r\n            let props = {};\r\n            let computedStyle = window.getComputedStyle(el, '');\r\n            prop.forEach(_prop => {\r\n                props[_prop] = (el.style[_prop] || computedStyle.getPropertyValue(_prop));\r\n            });\r\n            return props;\r\n        }\r\n    }\r\n\r\n    if (_is.str(prop)) {\r\n        if (!val && val !== 0) {\r\n            each(_el, el => { el.style.removeProperty(prop); });\r\n        } else {\r\n            css = prop + \":\" + _maybeAddPx(prop, val);\r\n        }\r\n    } else {\r\n        for (key in prop) {\r\n            if (!prop[key] && prop[key] !== 0) {\r\n                each(_el, el => { el.style.removeProperty(key); });\r\n            } else {\r\n                css += key + ':' + _maybeAddPx(key, prop[key]) + ';';\r\n            }\r\n        }\r\n    }\r\n\r\n    return each(_el, el => { el.style.cssText += ';' + css; });\r\n};\r\n\r\n// Generate the `width` and `height` methods\r\nexport let { width, height } = ['width', 'height'].reduce((acc, sz) => {\r\n    let prop = _capital(sz);\r\n    acc[sz] = (_el, value) => {\r\n        let _offset, el = first(_el);\r\n        if (_is.undef(value)) {\r\n            if (_is.win(el)) {\r\n                return el[`inner${prop}`];\r\n            } else if (_is.doc(el)) {\r\n                return el.documentElement[`scroll${prop}`];\r\n            } else { return (_offset = offset(_el)) && _offset[sz]; }\r\n        } else {\r\n            return each(_el, ($el, idx) => {\r\n                style($el, sz, _fnval(value, [idx, el[sz]()], $el));\r\n            });\r\n        }\r\n    };\r\n\r\n    return acc;\r\n}, {});\r\n\r\n// Show/hide an element\r\nexport let show = _el => { return style(_el, \"display\", \"\"); };\r\nexport let hide = _el => { return style(_el, \"display\", \"none\"); };\r\n\r\n// Toggle between showing and hiding each of element in the ele object, based on whether the first element is visible or not.\r\nexport let toggle = (_el, opt) => {\r\n    return each(_el, el => {\r\n        let _el = _elem(el);\r\n        let _opt = opt || style(_el, \"display\") === \"none\";\r\n        _opt ? show(_el) : hide(_el)\r\n    });\r\n};\r\n\r\n// Select element siblings based on selector\r\nexport let prev = (_el, sel) => filter(pluck(_el, 'previousElementSibling'), sel || '*');\r\nexport let next = (_el, sel) => filter(pluck(_el, 'nextElementSibling'), sel || '*');\r\n\r\n// Empty the value of an element in the ele object\r\nexport let empty = _el => each(_el, el => { el.innerHTML = ''; });\r\n\r\n// Get or set HTML contents of elements in the collection. When no content given, returns innerHTML of the first element.\r\nexport let html = (_el, ...args) => {\r\n    let [html] = args;\r\n    _el = el(_el);\r\n    return args.length ?\r\n        each(_el, (el, idx) => {\r\n            let originHTML = el.innerHTML;\r\n            append(empty(el), _fnval(html, [idx, originHTML], el));\r\n        }) : (_el.length ? first(_el).innerHTML : null);\r\n};\r\n\r\nexport let text = (_el, ...args) => {\r\n    let [text] = args;\r\n    _el = el(_el);\r\n    return args.length ?\r\n        each(_el, (el, idx) => {\r\n            let newText = _fnval(text, [idx, el.textContent], el);\r\n            el.textContent = _is.nul(newText) ? '' : `${newText}`;\r\n        }) : (_el.length ? pluck(_el, 'textContent').join(\"\") : null);\r\n};\r\n\r\n// Quickly set the value of an attribute or remove the attribute completely from a node\r\nlet _setAttr = (node, name, value) => value === null ? node.removeAttribute(name) : node.setAttribute(name, value);\r\n\r\n// Set the attribute of elements in the ele object\r\nexport let attr = (_el, name, val) => {\r\n    let result;\r\n    _el = el(_el);\r\n    if (_is.str(name) && _is.undef(val)) {\r\n        result = _el.length && first(_el).nodeType === 1 &&\r\n            first(_el).getAttribute(name);\r\n        return !_is.nul(result) ? result : undefined;\r\n    } else {\r\n        return each(_el, (el, idx) => {\r\n            if (el.nodeType !== 1) return;\r\n            if (_is.arr(name)) {\r\n                for (let i in name)\r\n                    _setAttr(el, i, name[i]);\r\n            } else {\r\n                _setAttr(el, name, _fnval(val, [idx, el.getAttribute(name)], el));\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\n// Remove an attribute from all elements in the ele object\r\nexport let removeAttr = (_el, name) => {\r\n    return each(_el, el => {\r\n        el.nodeType === 1 && name.split(' ')\r\n            .forEach(attr => { _setAttr(el, attr); });\r\n    });\r\n};\r\n\r\n// Transform string values to the proper type of value eg. \"12\" = 12, \"[12, 'xyz']\" = [12, 'xyz']\r\nlet _valfix = value => {\r\n    let validTypes = /^true|false|null|undefined|\\d+$/;\r\n    let _fn = v => Function(`\"use strict\"; return ${v};`) ();\r\n    let objectType = /^[[{]([\\s\\S]+)?[\\]}]$/;\r\n    try {\r\n        return validTypes.test(value) ? _fn(value) :\r\n            objectType.test(value) ? JSON.parse(value.replace(/'/g, \"\\\"\")) : value;\r\n    } catch (e) { return value; }\r\n};\r\n\r\n// Read or write data-* DOM attributes. Behaves like attr, but prepends data- to the attribute name.\r\nexport let data = (_el, name, value) => {\r\n    let attrName = `data-${name}`.toLowerCase();\r\n    let data = _is.def(value) ? attr(_el, attrName, value) : attr(_el, attrName);\r\n    return data !== null ? _valfix(data) : undefined;\r\n};\r\n\r\n/* Get or set the value of form controls. When no value is given, return the value of the first element.\r\n   For <select multiple>, an array of values is returend. When a value is given, set all elements to this value. */\r\nexport let val = (_el, value, ...args) => {\r\n    _el = el(_el);\r\n    if (args.length) {\r\n        if (_is.nul(value)) value = \"\";\r\n        return each(_el, (el, idx) => {\r\n            el.value = _fnval(value, [idx, el.value], el);\r\n        });\r\n    } else {\r\n        _el = first(_el);\r\n        return _el && (_el.multiple ?\r\n            pluck(filter(find(_el, 'option'), el => el.selected), 'value') :\r\n            _el.value);\r\n    }\r\n};\r\n\r\n// Get position of the element in the document. Returns an object with properties: top, left, width and height.\r\nexport let offset = (_el, coords) => {\r\n    let obj;\r\n    _el = el(_el);\r\n    if (coords) {\r\n        return each(_el, (el, idx) => {\r\n            let $this = new ele(el);\r\n            let _coords = _fnval(coords, [idx, offset($this)], el);\r\n            let parentOffset = offset(offsetParent($this));\r\n            let props = {\r\n                top: _coords.top - parentOffset.top,\r\n                left: _coords.left - parentOffset.left\r\n            };\r\n\r\n            if (style($this, 'position') === 'static') props.position = 'relative';\r\n            style($this, props);\r\n        })\r\n    }\r\n\r\n    if (!_el.length) return null;\r\n    if (document.documentElement !== first(_el) && !_contains(document.documentElement, first(_el)))\r\n        return { top: 0, left: 0 };\r\n\r\n    obj = first(_el).getBoundingClientRect();\r\n    return {\r\n        left: obj.left + window.pageXOffset,\r\n        top: obj.top + window.pageYOffset,\r\n        width: Math.round(obj.width),\r\n        height: Math.round(obj.height)\r\n    };\r\n};\r\n\r\n// Get the position of an element in the ele object collection. When no element is given, returns position of the current element among its siblings. When an element is given, returns its position in the current collection. Returns -1 if not found.\r\nexport let index = (_el, el) => {\r\n    _el = new ele(_el);\r\n    return el ? indexOf(_el, first(el)) : indexOf(children(parent(_el)), first(_el));\r\n};\r\n\r\n// Class name cache\r\nlet classcache = {};\r\n\r\n// Get the class name for an element\r\nlet getclass = (node, value) => {\r\n    let name = node.className || '';\r\n    let svg  = name && !_is.undef(name.baseVal);\r\n\r\n    if (_is.undef(value)) return svg ? name.baseVal : name;\r\n    svg ? (name.baseVal = value) : (node.className = value);\r\n};\r\n\r\n// Class name RegExp\r\nlet _classRE = name => {\r\n    return name in classcache ? classcache[name] :\r\n        (classcache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'));\r\n};\r\n\r\n// Check if any elements in the collection have the specified class.\r\nexport let hasClass = (_el, name) => {\r\n    if (!name) return false;\r\n    return [].some.call(el(_el), el => {\r\n        return _classRE(name).test(getclass(el));\r\n    });\r\n};\r\n\r\n// Add class name to each of the elements in the collection. Multiple class names can be given in a space-separated string.\r\nexport let addClass = (_el, name) => {\r\n    _el = el(_el);\r\n    if (!name) return _el;\r\n    return each(_el, (el, idx) => {\r\n        if (!('className' in el)) return;\r\n\r\n        let classList = [], cls = getclass(el);\r\n        _fnval(name, [idx, cls], el).split(/\\s+/g).forEach(_name => {\r\n            if (!hasClass(el, _name)) classList.push(_name);\r\n        });\r\n\r\n        classList.length && getclass(el, cls + (cls ? \" \" : \"\") + classList.join(\" \"));\r\n    });\r\n};\r\n\r\n// Remove the specified class name from all elements in the collection. When the class name isn’t given, remove all class names. Multiple class names can be given in a space-separated string.\r\nexport let removeClass = (_el, name) => {\r\n    return each(_el, function (el, idx) {\r\n        if (!('className' in el)) return;\r\n        if (_is.undef(name)) return getclass(el, '');\r\n\r\n        let classList = getclass(el);\r\n        _fnval(name, [idx, classList], el).split(/\\s+/g).forEach(_name => {\r\n            classList = classList.replace(_classRE(_name), \" \");\r\n        });\r\n\r\n        getclass(el, classList.trim());\r\n    });\r\n};\r\n\r\n// Toggle given class names (space-separated) in each element in the collection. The class name is removed if present on an element; otherwise it’s added.\r\nexport let toggleClass = (_el, name, when) => {\r\n    _el = el(_el);\r\n    if (!name) return _el;\r\n    return each(_el, function (el, idx) {\r\n        let $this = new ele(el);\r\n        _fnval(name, [idx, getclass(el)], el).split(/\\s+/g)\r\n        .forEach(_name => {\r\n            (_is.undef(when) ? !hasClass($this, _name) : when) ?\r\n            addClass($this, _name) : removeClass($this, _name);\r\n        });\r\n    });\r\n};\r\n\r\n// Find the first ancestor element that is positioned, meaning its CSS position value is \"relative\", \"absolute\" or \"fixed\".\r\nexport let offsetParent = _el => {\r\n    return map(_el, el => {\r\n        let parent = el.offsetParent || document.body;\r\n        while (parent && !/^(?:body|html)$/i.test(parent.nodeName) &&\r\n            style(parent, \"position\") === \"static\") {\r\n            parent = parent.offsetParent;\r\n        }\r\n        return parent;\r\n    });\r\n};\r\n\r\n// Get the position of the first element in the collection, relative to the offsetParent. This information is useful when absolutely positioning an element to appear aligned with another.\r\nexport let position = _el => {\r\n    _el = el(_el);\r\n    if (!_el.length) return;\r\n\r\n    let elem = first(_el),\r\n        _offsetParent = offsetParent(_el),\r\n        _offset = offset(_el),\r\n        parentOffset = /^(?:body|html)$/i.test(_offsetParent[0].nodeName) ? { top: 0, left: 0 } : offset(_offsetParent);\r\n\r\n    _offset.top -= parseFloat(style(elem, 'margin-top')) || 0;\r\n    _offset.left -= parseFloat(style(elem, 'margin-left')) || 0;\r\n\r\n    parentOffset.top += parseFloat(style(_offsetParent[0], 'border-top-width')) || 0;\r\n    parentOffset.left += parseFloat(style(_offsetParent[0], 'border-left-width')) || 0;\r\n\r\n    return {\r\n        top: _offset.top - parentOffset.top,\r\n        left: _offset.left - parentOffset.left\r\n    }\r\n};\r\n\r\n// Gets or sets how many pixels were scrolled down so far on window or scrollable element on the page.\r\nexport let scrollTop = (_el, val) => {\r\n    _el = el(_el);\r\n    if (!_el.length) return;\r\n\r\n    let hasScroll = 'scrollTop' in first(_el);\r\n    if (_is.undef(val)) return first(_el)[hasScroll ? \"scrollTop\" : \"pageYOffset\"];\r\n    return each(_el, el => {\r\n        hasScroll ? (el.scrollTop = val) : el.scrollTo(el.scrollX, val);\r\n    });\r\n};\r\n\r\n// Gets or sets how many pixels were scrolled right so far on window or scrollable element on the page.\r\nexport let scrollLeft = (_el, val) => {\r\n    _el = el(_el);\r\n    if (!_el.length) return;\r\n\r\n    let hasScroll = 'scrollLeft' in first(_el);\r\n    if (_is.undef(val)) return first(_el)[hasScroll ? \"scrollLeft\" : \"pageXOffset\"];\r\n    return each(_el, el => {\r\n        hasScroll ? (el.scrollLeft = val) : el.scrollTo(val, el.scrollY);\r\n    });\r\n};\r\n\r\n// Generate shortforms for events eg. onclick(), onhover(), etc...\r\nexport let { onready, onload, onblur, onfocus, onfocusin, onfocusout, onresize, onclick, onscroll, ondblclick, onmousedown, onmouseup, onmousemove, onmouseover, onmouseout, onmouseenter, onmouseleave, onchange, onselect, onsubmit, onkeydown, onkeypress, onkeyup, oncontextmenu } = `ready load blur focus focusin focusout resize click scroll dblclick mousedown\r\n    mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit\r\n    keydown keypress keyup contextmenu`.split(/[\\s\\n]+/g)\r\n.reduce((acc, name) => {\r\n    // Handle event binding\r\n    acc[`on${name}`] = (_el, ...args) => el(_el).on(name, ...args);\r\n    return acc;\r\n}, {\r\n    onhover: (_el, fnOver, fnOut) =>\r\n        el(_el).on(\"mouseenter\", fnOver)\r\n               .on(\"mouseleave\", fnOut || fnOver)\r\n});\r\n\r\nexport default el;"]}