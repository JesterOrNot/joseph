// export const { assign, keys, values } = Object;
// export let { isArray, from, of } = Array;
const assign = Object.assign;
const keys = Object.keys;
const isArray = Array.isArray;

let _log = (...args) => args.forEach(v => console.log(v)); // Capitalize strings

let _capital = val => val[0].toUpperCase() + val.slice(1); // Test the type of a value

let _is = (val, type) => typeof val === type; // Is Instance Of

let _isInst = (ctor, obj) => ctor instanceof obj;

let _type = type => {
  // Tweak of _is
  return val => _is(val, type);
};

assign(_is, {
  el: el => _isInst(el, Element) || _isInst(el, Document),

  arrlike(obj) {
    let len = _is(obj.length, "number") && obj.length;
    return len === 0 || len > 0 && len - 1 in obj;
  },

  num: val => !isNaN(val) && _type("number")(val),
  usable: v => !_is(v, "undefined") && v !== null,
  class: obj => obj && obj._method && obj._class,
  not: (type, ...args) => !_is[type](...args),
  doc: ctor => _isInst(ctor, Document),
  def: v => !_is(v, "undefined"),
  undef: _type("undefined"),
  win: v => v && v.window,
  bool: _type("boolean"),
  fn: _type("function"),
  str: _type("string"),
  obj: _type("object"),
  nul: v => v === null,
  inst: _isInst,
  arr: isArray,
  _type
});
/**
 * @param  {Function} fn
 * @param  {Array<any>} args
 * @param  {Object} ctxt
 */

let _fnval = (fn, args, ctxt) => {
  if (!_is.fn(fn) || keys(fn.prototype || {}).length > 0) {
    return fn;
  }

  return fn.apply(ctxt, args);
};

let _matches = (ele, sel) => {
  if (_is.undef(ele)) return;
  let matchSel = _is.el(sel) ? el => {
    var matches = [el],
        i = matches.length;

    while (--i >= 0 && matches[i] !== ele);

    return i > -1;
  } : ele.matches || ele.msMatchesSelector || ele.webkitMatchesSelector;
  if (matchSel) return matchSel.call(ele, sel);
}; // A more efficient `new` keyword that allows for arrays to be passed as arguments

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var rellax = createCommonjsModule(function (module) {
  // ------------------------------------------
  // Rellax.js
  // Buttery smooth parallax library
  // Copyright (c) 2016 Moe Amaya (@moeamaya)
  // MIT license
  //
  // Thanks to Paraxify.js and Jaime Cabllero
  // for parallax concepts
  // ------------------------------------------
  (function (root, factory) {
    if ( module.exports) {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory();
    } else {
      // Browser globals (root is window)
      root.Rellax = factory();
    }
  })(typeof window !== "undefined" ? window : commonjsGlobal, function () {
    var Rellax = function (el, options) {

      var self = Object.create(Rellax.prototype);
      var posY = 0;
      var screenY = 0;
      var posX = 0;
      var screenX = 0;
      var blocks = [];
      var pause = true; // check what requestAnimationFrame to use, and if
      // it's not supported, use the onscroll event

      var loop = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) {
        return setTimeout(callback, 1000 / 60);
      }; // store the id for later use


      var loopId = null; // Test via a getter in the options object to see if the passive property is accessed

      var supportsPassive = false;

      try {
        var opts = Object.defineProperty({}, 'passive', {
          get: function () {
            supportsPassive = true;
          }
        });
        window.addEventListener("testPassive", null, opts);
        window.removeEventListener("testPassive", null, opts);
      } catch (e) {} // check what cancelAnimation method to use


      var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout; // check which transform property to use

      var transformProp = window.transformProp || function () {
        var testEl = document.createElement('div');

        if (testEl.style.transform === null) {
          var vendors = ['Webkit', 'Moz', 'ms'];

          for (var vendor in vendors) {
            if (testEl.style[vendors[vendor] + 'Transform'] !== undefined) {
              return vendors[vendor] + 'Transform';
            }
          }
        }

        return 'transform';
      }(); // Default Settings


      self.options = {
        speed: -2,
        center: false,
        wrapper: null,
        relativeToWrapper: false,
        round: true,
        vertical: true,
        horizontal: false,
        callback: function () {}
      }; // User defined options (might have more in the future)

      if (options) {
        Object.keys(options).forEach(function (key) {
          self.options[key] = options[key];
        });
      } // By default, rellax class


      if (!el) {
        el = '.rellax';
      } // check if el is a className or a node


      var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el]; // Now query selector

      if (elements.length > 0) {
        self.elems = elements;
      } // The elements don't exist
      else {
          console.warn("Rellax: The elements you're trying to select don't exist.");
          return;
        } // Has a wrapper and it exists


      if (self.options.wrapper) {
        if (!self.options.wrapper.nodeType) {
          var wrapper = document.querySelector(self.options.wrapper);

          if (wrapper) {
            self.options.wrapper = wrapper;
          } else {
            console.warn("Rellax: The wrapper you're trying to use doesn't exist.");
            return;
          }
        }
      } // Get and cache initial position of all elements


      var cacheBlocks = function () {
        for (var i = 0; i < self.elems.length; i++) {
          var block = createBlock(self.elems[i]);
          blocks.push(block);
        }
      }; // Let's kick this script off
      // Build array for cached element values


      var init = function () {
        for (var i = 0; i < blocks.length; i++) {
          self.elems[i].style.cssText = blocks[i].style;
        }

        blocks = [];
        screenY = window.innerHeight;
        screenX = window.innerWidth;
        setPosition();
        cacheBlocks();
        animate(); // If paused, unpause and set listener for window resizing events

        if (pause) {
          window.addEventListener('resize', init);
          pause = false; // Start the loop

          update();
        }
      }; // We want to cache the parallax blocks'
      // values: base, top, height, speed
      // el: is dom object, return: el cache values


      var createBlock = function (el) {
        var dataPercentage = el.getAttribute('data-rellax-percentage');
        var dataSpeed = el.getAttribute('data-rellax-speed');
        var dataZindex = el.getAttribute('data-rellax-zindex') || 0;
        var dataMin = el.getAttribute('data-rellax-min');
        var dataMax = el.getAttribute('data-rellax-max'); // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)
        // ensures elements are positioned based on HTML layout.
        //
        // If the element has the percentage attribute, the posY and posX needs to be
        // the current scroll position's value, so that the elements are still positioned based on HTML layout

        var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.

        if (self.options.relativeToWrapper) {
          var scrollPosY = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
          wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;
        }

        var posY = self.options.vertical ? dataPercentage || self.options.center ? wrapperPosY : 0 : 0;
        var posX = self.options.horizontal ? dataPercentage || self.options.center ? self.options.wrapper ? self.options.wrapper.scrollLeft : window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft : 0 : 0;
        var blockTop = posY + el.getBoundingClientRect().top;
        var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;
        var blockLeft = posX + el.getBoundingClientRect().left;
        var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth; // apparently parallax equation everyone uses

        var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);
        var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);

        if (self.options.center) {
          percentageX = 0.5;
          percentageY = 0.5;
        } // Optional individual block speed as data attr, otherwise global speed


        var speed = dataSpeed ? dataSpeed : self.options.speed;
        var bases = updatePosition(percentageX, percentageY, speed); // ~~Store non-translate3d transforms~~
        // Store inline styles and extract transforms

        var style = el.style.cssText;
        var transform = ''; // Check if there's an inline styled transform

        var searchResult = /transform\s*:/i.exec(style);

        if (searchResult) {
          // Get the index of the transform
          var index = searchResult.index; // Trim the style to the transform point and get the following semi-colon index

          var trimmedStyle = style.slice(index);
          var delimiter = trimmedStyle.indexOf(';'); // Remove "transform" string and save the attribute

          if (delimiter) {
            transform = " " + trimmedStyle.slice(11, delimiter).replace(/\s/g, '');
          } else {
            transform = " " + trimmedStyle.slice(11).replace(/\s/g, '');
          }
        }

        return {
          baseX: bases.x,
          baseY: bases.y,
          top: blockTop,
          left: blockLeft,
          height: blockHeight,
          width: blockWidth,
          speed: speed,
          style: style,
          transform: transform,
          zindex: dataZindex,
          min: dataMin,
          max: dataMax
        };
      }; // set scroll position (posY, posX)
      // side effect method is not ideal, but okay for now
      // returns true if the scroll changed, false if nothing happened


      var setPosition = function () {
        var oldY = posY;
        var oldX = posX;
        posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;
        posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset; // If option relativeToWrapper is true, use relative wrapper value instead.

        if (self.options.relativeToWrapper) {
          var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;
          posY = scrollPosY - self.options.wrapper.offsetTop;
        }

        if (oldY != posY && self.options.vertical) {
          // scroll changed, return true
          return true;
        }

        if (oldX != posX && self.options.horizontal) {
          // scroll changed, return true
          return true;
        } // scroll did not change


        return false;
      }; // Ahh a pure function, gets new transform value
      // based on scrollPosition and speed
      // Allow for decimal pixel values


      var updatePosition = function (percentageX, percentageY, speed) {
        var result = {};
        var valueX = speed * (100 * (1 - percentageX));
        var valueY = speed * (100 * (1 - percentageY));
        result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;
        result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;
        return result;
      }; // Remove event listeners and loop again


      var deferredUpdate = function () {
        window.removeEventListener('resize', deferredUpdate);
        window.removeEventListener('orientationchange', deferredUpdate);
        (self.options.wrapper ? self.options.wrapper : window).removeEventListener('scroll', deferredUpdate);
        (self.options.wrapper ? self.options.wrapper : document).removeEventListener('touchmove', deferredUpdate); // loop again

        loopId = loop(update);
      }; // Loop


      var update = function () {
        if (setPosition() && pause === false) {
          animate(); // loop again

          loopId = loop(update);
        } else {
          loopId = null; // Don't animate until we get a position updating event

          window.addEventListener('resize', deferredUpdate);
          window.addEventListener('orientationchange', deferredUpdate);
          (self.options.wrapper ? self.options.wrapper : window).addEventListener('scroll', deferredUpdate, supportsPassive ? {
            passive: true
          } : false);
          (self.options.wrapper ? self.options.wrapper : document).addEventListener('touchmove', deferredUpdate, supportsPassive ? {
            passive: true
          } : false);
        }
      }; // Transform3d on parallax element


      var animate = function () {
        var positions;

        for (var i = 0; i < self.elems.length; i++) {
          var percentageY = (posY - blocks[i].top + screenY) / (blocks[i].height + screenY);
          var percentageX = (posX - blocks[i].left + screenX) / (blocks[i].width + screenX); // Subtracting initialize value, so element stays in same spot as HTML

          positions = updatePosition(percentageX, percentageY, blocks[i].speed); // - blocks[i].baseX;

          var positionY = positions.y - blocks[i].baseY;
          var positionX = positions.x - blocks[i].baseX; // The next two "if" blocks go like this:
          // Check if a limit is defined (first "min", then "max");
          // Check if we need to change the Y or the X
          // (Currently working only if just one of the axes is enabled)
          // Then, check if the new position is inside the allowed limit
          // If so, use new position. If not, set position to limit.
          // Check if a min limit is defined

          if (blocks[i].min !== null) {
            if (self.options.vertical && !self.options.horizontal) {
              positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;
            }

            if (self.options.horizontal && !self.options.vertical) {
              positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;
            }
          } // Check if a max limit is defined


          if (blocks[i].max !== null) {
            if (self.options.vertical && !self.options.horizontal) {
              positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;
            }

            if (self.options.horizontal && !self.options.vertical) {
              positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;
            }
          }

          var zindex = blocks[i].zindex; // Move that element
          // (Set the new translation and append initial inline transforms.)

          var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;
          self.elems[i].style[transformProp] = translate;
        }

        self.options.callback(positions);
      };

      self.destroy = function () {
        for (var i = 0; i < self.elems.length; i++) {
          self.elems[i].style.cssText = blocks[i].style;
        } // Remove resize event listener if not pause, and pause


        if (!pause) {
          window.removeEventListener('resize', init);
          pause = true;
        } // Clear the animation loop to prevent possible memory leak


        clearLoop(loopId);
        loopId = null;
      }; // Init


      init(); // Allow to recalculate the initial values whenever we want

      self.refresh = init;
      return self;
    };

    return Rellax;
  });
});

let ele;
let tagRE = /^\s*<(\w+|!)[^>]*>/;
let tagExpandRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig;
let _qsa = (dom = document, sel) => {
  let classes;
  if (!_is.str(sel) && sel.length === 0) return [];

  if (/^(#?[\w-]+|\.[\w-.]+)$/.test(sel)) {
    switch (sel.charAt(0)) {
      case '#':
        return [dom.getElementById(sel.substr(1))];

      case '.':
        classes = sel.substr(1).replace(/\./g, ' ');
        return [...dom.getElementsByClassName(classes)];

      default:
        return [...dom.getElementsByTagName(sel)];
    }
  }

  return [...dom.querySelectorAll(sel)];
}; // Create an Element List from a HTML string

let _createElem = html => {
  let dom, container;
  container = document.createElement('div');
  container.innerHTML = '' + html.replace(tagExpandRE, "<$1></$2>");
  dom = [].slice.call(container.childNodes);
  dom.forEach(el => {
    container.removeChild(el);
  });
  return dom;
}; // Element selector

let _elem = (sel, ctxt) => {
  if (_is.str(sel)) {
    sel = sel.trim();

    if (tagRE.test(sel)) {
      return _createElem(sel);
    } else {
      return _qsa(ctxt, sel);
    }
  } else if (_is.inst(sel, ele)) {
    return sel;
  } else if (_is.arr(sel) || _is.inst(sel, NodeList)) {
    return [...sel].filter(item => _is.def(item));
  } else if (_is.obj(sel) || _is.el(sel)) {
    return [sel];
  } else if (_is.fn(sel)) {
    return _elem(sel());
  }

  return [];
}; // Element Object [Based on Zepto.js]

var ele$1 = ele = class {
  constructor(sel = '', ctxt) {
    this.sel = sel; // Selector

    this.ele = _elem(this.sel, ctxt); // Element

    for (let i = 0; i < this.ele.length; i++) {
      this[i] = this.ele[i];
    }

    this.length = this.ele.length;
  }

};

let el = (sel, ctxt) => {
  return _is.inst(sel, ele$1) && !_is.usable(ctxt) ? sel : new ele$1(sel, ctxt);
}; // Select specific element at an index of the ele object

let get = (_el, idx) => {
  _el = el(_el);
  return !_is.num(idx) ? [].slice.call(_el) : _el[idx >= 0 ? idx : idx + _el.length];
};

let toArray = val => _is.inst(val, ele$1) ? get(val) : val; // Convert ele objects to arrays

let _concat = function (...args) {
  [].map.call(args, val => toArray(val)); // Transform Elements to Arrays

  return [].concat(...args);
}; // Map objects and remove undefined/null values


let _map = (obj, fn, ctxt) => {
  let arr = [].map.call(obj, fn, ctxt).filter(item => _is.usable(item)); // Creates a flat Array of Objects

  return arr.length > 0 ? _concat(...arr) : arr;
}; // Added support for element mapping


let map = (_el, fn) => {
  _el = el(_el);
  return el(_map(_el, (el, i) => fn.call(el, el, i)));
}; // Functions the same way Array.forEach does
/* Similar to forEach, however, the context of the iterator is set and
   it allows the iterators return value to stop the iteration just like Array.every */

let each = (_el, fn) => {
  _el = el(_el);
  [].every.call(_el, function (el, idx) {
    return fn.call(el, el, idx) !== false;
  });
  return _el;
}; // Quickly filter nodes by a selector

let filter = (_el, sel) => {
  _el = el(_el);
  if (_is.undef(sel)) return _el;
  return el([].filter.call(_el, _is.fn(sel) ? sel : ele => _matches(ele, sel), _el));
}; // Check if the parent node contains the given DOM node. Returns false if both are the same node.

let _contains = (parent, node) => {
  if (parent.contains) return parent !== node && parent.contains(node);

  while (node && (node = node.parentNode)) if (node === parent) return true;

  return false;
}; // Find an element that matches a selector in a ele object


let find = (_el, sel) => {
  let result;
  _el = el(_el);
  if (!sel) result = el();else if (_is.obj(sel)) {
    result = filter(sel, el => {
      return [].some.call(_el, parent => _contains(parent, el));
    });
  } else if (_el.length === 1) {
    result = el(_qsa(get(_el, 0), sel));
  } else {
    result = map(_el, el => _qsa(el, sel));
  }
  return result;
}; // Check to see if a ele object has a certain element
// CSS properties that use unitless numbers

let _cssNumber = ["column-count", "columns", "font-weight", "line-height", "opacity", "z-index", "zoom"]; // Decide if the value deserves px at the

let _maybeAddPx = (name, val) => {
  return _is.num(+val) && !_cssNumber.includes(name) ? `${val}px` : val;
}; // Read or set CSS properties on DOM elements.


let style = (_el, ...args) => {
  let [prop, val] = args,
      css = '',
      key;

  if (args.length < 2) {
    let el = get(_el, 0);
    if (!el) return;

    if (_is.str(prop)) {
      return el.style[prop] || window.getComputedStyle(el, '').getPropertyValue(prop);
    } else if (_is.arr(prop)) {
      let props = {};
      let computedStyle = window.getComputedStyle(el, '');
      prop.forEach(_prop => {
        props[_prop] = el.style[_prop] || computedStyle.getPropertyValue(_prop);
      });
      return props;
    }
  }

  if (_is.str(prop)) {
    if (!val && val !== 0) {
      each(_el, el => {
        el.style.removeProperty(prop);
      });
    } else {
      css = prop + ":" + _maybeAddPx(prop, val);
    }
  } else {
    for (key in prop) {
      if (!prop[key] && prop[key] !== 0) {
        each(_el, el => {
          el.style.removeProperty(key);
        });
      } else {
        css += key + ':' + _maybeAddPx(key, prop[key]) + ';';
      }
    }
  }

  return each(_el, el => {
    el.style.cssText += ';' + css;
  });
}; // Method for creating size methods

let _size = sz => {
  let prop = _capital(sz);

  return (_el, value) => {
    let _offset,
        el = get(_el, 0);

    if (_is.undef(value)) {
      if (_is.win(el)) {
        return el[`inner${prop}`];
      } else if (_is.doc(el)) {
        return el.documentElement[`scroll${prop}`];
      } else {
        return (_offset = offset(_el)) && _offset[sz];
      }
    } else {
      return each(_el, ($el, idx) => {
        style($el, sz, _fnval(value, [idx, el[sz]()], $el));
      });
    }
  };
}; // Generate the `width` and `height` methods


let width = _size("width");
let height = _size("height"); // Show/hide an element

let offset = (_el, coords) => {
  let obj;
  _el = el(_el);

  if (coords) {
    return each(_el, (el, idx) => {
      let $this = new ele$1(el);

      let _coords = _fnval(coords, [idx, offset($this)], el);

      let parentOffset = offset(offsetParent($this));
      let props = {
        top: _coords.top - parentOffset.top,
        left: _coords.left - parentOffset.left
      };
      if (style($this, 'position') === 'static') props.position = 'relative';
      style($this, props);
    });
  }

  if (!_el.length) return null;
  if (document.documentElement !== get(_el, 0) && !_contains(document.documentElement, get(_el, 0))) return {
    top: 0,
    left: 0
  };
  obj = get(_el, 0).getBoundingClientRect();
  return {
    left: obj.left + window.pageXOffset,
    top: obj.top + window.pageYOffset,
    width: Math.round(obj.width),
    height: Math.round(obj.height)
  };
}; // Get the position of an element in the ele object collection. When no element is given, returns position of the current element among its siblings. When an element is given, returns its position in the current collection. Returns -1 if not found.

let classcache = {}; // Class name RegExp

let _classRE = name => {
  return name in classcache ? classcache[name] : classcache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)');
}; // Get the class name for an element


let getclass = (node, value) => {
  let name = node.className || '';
  let svg = name && !_is.undef(name.baseVal);
  if (_is.undef(value)) return svg ? name.baseVal : name;
  svg ? name.baseVal = value : node.className = value;
}; // Check if any elements in the collection have the specified class.


let hasClass = (_el, name) => {
  if (!name) return false;
  return [].some.call(el(_el), el => {
    return _classRE(name).test(getclass(el));
  });
}; // Add class name to each of the elements in the collection. Multiple class names can be given in a space-separated string.

let addClass = (_el, name) => {
  _el = el(_el);
  if (!name) return _el;
  return each(_el, (el, idx) => {
    if (!('className' in el)) return;
    let classList = [],
        cls = getclass(el);

    _fnval(name, [idx, cls], el).split(/\s+/g).forEach(_name => {
      if (!hasClass(el, _name)) classList.push(_name);
    });

    classList.length && getclass(el, cls + (cls ? " " : "") + classList.join(" "));
  });
}; // Remove the specified class name from all elements in the collection. When the class name isn’t given, remove all class names. Multiple class names can be given in a space-separated string.

let removeClass = (_el, name) => {
  return each(_el, function (el, idx) {
    if (!('className' in el)) return;
    if (_is.undef(name)) return getclass(el, '');
    let classList = getclass(el);

    _fnval(name, [idx, classList], el).split(/\s+/g).forEach(_name => {
      classList = classList.replace(_classRE(_name), " ");
    });

    getclass(el, classList.trim());
  });
}; // Toggle given class names (space-separated) in each element in the collection. The class name is removed if present on an element; otherwise it’s added.

let toggleClass = (_el, name, when) => {
  _el = el(_el);
  if (!name) return _el;
  return each(_el, function (el, idx) {
    let $this = new ele$1(el);

    _fnval(name, [idx, getclass(el)], el).split(/\s+/g).forEach(_name => {
      (_is.undef(when) ? !hasClass($this, _name) : when) ? addClass($this, _name) : removeClass($this, _name);
    });
  });
}; // Find the first ancestor element that is positioned, meaning its CSS position value is "relative", "absolute" or "fixed".

let offsetParent = _el => {
  return map(_el, el => {
    let parent = el.offsetParent || document.body;

    while (parent && !/^(?:body|html)$/i.test(parent.nodeName) && style(parent, "position") === "static") {
      parent = parent.offsetParent;
    }

    return parent;
  });
}; // Get the position of the first element in the collection, relative to the offsetParent. This information is useful when absolutely positioning an element to appear aligned with another.

let scrollTop = (_el, val) => {
  _el = el(_el);
  if (!_el.length) return;
  let hasScroll = 'scrollTop' in get(_el, 0);
  if (_is.undef(val)) return get(_el, 0)[hasScroll ? "scrollTop" : "pageYOffset"];
  return each(_el, el => {
    hasScroll ? el.scrollTop = val : el.scrollTo(el.scrollX, val);
  });
}; // Gets or sets how many pixels were scrolled right so far on window or scrollable element on the page.

let scrollTo = (to, dur, ease) => {
  to = parseInt(to);
  dur = parseInt(dur);
  let start = window.pageYOffset,
      change = to - start,
      time = 0;

  let $ease = ease || ((time, start, change, length) => {
    if ((time /= length / 2) < 1) {
      return change / 2 * time * time + start;
    }

    return -change / 2 * (--time * (time - 2) - 1) + start;
  });

  let scroll,
      startTime = performance.now();
  return new Promise(resolve => {
    requestAnimationFrame(scroll = newTime => {
      time = newTime - startTime;
      window.scroll(0, $ease(time, start, change, dur));

      if (time < dur) {
        requestAnimationFrame(scroll);
      } else {
        window.scroll(0, to);
        resolve();
      }
    });
  });
}; // Test for passive support, based on [github.com/rafrex/detect-passive-events]

let passive = false,
    opts = {},
    noop = () => {};

try {
  opts = Object.defineProperty({}, "passive", {
    get: () => passive = {
      capture: false,
      passive: true
    }
  });
  window.addEventListener("PassiveEventTest", noop, opts);
  window.removeEventListener("PassiveEventsTest", noop, opts);
} catch (e) {} // Alias for the addEventListener; supports multiple elements


let on = ($el, evt, fn, opts) => {
  let $evt, _emit, useCapture;

  if (_is.undef(evt)) {
    return;
  } // If there is no event break


  if (_is.str(evt)) {
    evt = evt.split(/\s/g);
  }

  if (!_is.arr(evt) && !_is.obj(evt)) {
    evt = [evt];
  } // Set evt to an array


  return each($el, (_el, i) => {
    _emit = e => fn(e, _el, i); // Loop through the list of events


    keys(evt).forEach(key => {
      $evt = _is.obj(evt) && !_is.arr(evt) ? key : evt[key];

      if (/ready/.test($evt)) {
        if (!/in/.test(document.readyState)) {
          _emit({
            preventDefault: () => {}
          });
        } else if (document.addEventListener) {
          document.addEventListener('DOMContentLoaded', _emit);
        } else {
          // Support for IE
          document.attachEvent('onreadystatechange', e => {
            if (!/in/.test(document.readyState)) _emit(e);
          });
        }
      } else {
        useCapture = /blur|focus|touch/.test($evt);
        opts = opts || $evt === "scroll" ? passive || {} : {
          useCapture
        };

        _el.addEventListener($evt, _emit, opts);
      }
    });
  });
}; // Alias for the removeEventListener; supports multiple elements

let {
  onready,
  onload,
  onblur,
  onfocus,
  onfocusin,
  onfocusout,
  onresize,
  onclick,
  onscroll,
  ondblclick,
  onmousedown,
  onmouseup,
  onmousemove,
  onmouseover,
  onmouseout,
  onmouseenter,
  onmouseleave,
  onchange,
  onselect,
  onsubmit,
  onkeydown,
  onkeypress,
  onkeyup,
  oncontextmenu
} = `ready load blur focus focusin focusout resize click scroll dblclick mousedown
    mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit
    keydown keypress keyup contextmenu`.split(/[\s\n]+/g).reduce((acc, name) => {
  // Handle event binding
  acc[`on${name}`] = (_el, ...args) => on(_el, name, ...args);

  return acc;
}, {
  onhover: (_el, fnOver, fnOut) => on(_el, {
    mouseenter: fnOver,
    mouseleave: fnOut || fnOver
  })
});

let _global = el(window);
let _document = el(document);
let _body = el("html, body");

// import swup from "swup";
let _img = ".load-img";
let _navbar = '.navbar';
let _hero = ".layer-hero";
let _menu = '.navbar-menu';
let _backUp = '.back-to-top';
let _actioncenter = ".layer-action-center";
let _scrolldown = '.layer-hero-scroll-down';

let _height = height(_navbar);

let _focusPt = _height + 10;

on(_menu, "click touchstart", () => {
  toggleClass(_navbar, "navbar-show");
}); //

on(_backUp, "click touchstart", () => {
  scrollTo("0px", "700s");
}); //

on(_scrolldown, "click touchstart", () => {
  scrollTo(height(_hero) + _focusPt, "700s");
});
each(_img, $img => {
  let _core_img = get(find($img, ".core-img"), 0);

  let _placeholder_img = find($img, ".placeholder-img");

  if (_is.def(_core_img)) {
    if (_core_img.complete) {
      addClass(_placeholder_img, "core-img-show");
    } else {
      _core_img.addEventListener("load", function () {
        addClass(_placeholder_img, "core-img-show");
      }, false);
    }
  }
}); // Check to see is Object is in the window

let inWin = $el => {
  let {
    top,
    bottom
  } = $el.getBoundingClientRect();
  return top < window.innerHeight && bottom > 0;
};

let images = [];
each('.load-img', ($el, i) => {
  images[i] = new rellax($el, {
    speed: width(_global) >= 600 ? -6 : 0,
    center: false,
    round: false
  });
  images[i].destroy();

  _log("In Window: " + inWin($el));
});
onscroll(_global, () => {
  toggleClass(_navbar, "navbar-focus", scrollTop(_global) >= 5);
  hasClass(_navbar, "navbar-show") && removeClass(_navbar, "navbar-show");
  toggleClass(_actioncenter, "layer-action-center-show", scrollTop(_global) > _focusPt * 2);
  toggleClass(_actioncenter, "layer-action-center-hide", scrollTop(_global) <= _focusPt * 2);
  each('.load-img', ($el, i) => {
    if (inWin($el) && width(_global) >= 600) {
      images[i].refresh();
    } else {
      images[i].destroy();
    }

    i == 1 && console.log("Top: " + $el.getBoundingClientRect().top + " < Bottom: " + height(_global));

    _log("In Window: " + inWin($el));
  });
}); // new Rellax('.load-img', {
//     speed: width(_global) > 600 ? 2 : 0,
//     center: false,
//     round: false,
//     vertical: true,
//     horizontal: false
// })
// // helper functions
// const MathUtils = {
//     // map number x from range [a, b] to [c, d]
//     map: (x, a, b, c, d) => (x - a) * (d - c) / (b - a) + c,
//     // linear interpolation
//     lerp: (a, b, n) => (1 - n) * a + n * b
// };
// // body element
// const body = document.body;
// // calculate the viewport size
// let winsize;
// const calcWinsize = () => winsize = {width: window.innerWidth, height: window.innerHeight};
// calcWinsize();
// // and recalculate on resize
// window.addEventListener('resize', calcWinsize);
// // scroll position and update function
// let docScroll;
// const getPageYScroll = () => docScroll = window.pageYOffset || document.documentElement.scrollTop;
// window.addEventListener('scroll', getPageYScroll);
// // Item
// class Item {
//     constructor(el) {
//         // the .item element
//         this.DOM = {el: el};
//         // the inner image
//         this.DOM.image = this.DOM.el.querySelector('.core-img');
//         this.renderedStyles = {
//             // here we define which property will change as we scroll the page and the items is inside the viewport
//             // in this case we will be translating the image on the y-axis
//             // we interpolate between the previous and current value to achieve a smooth effect
//             innerTranslationY: {
//                 // interpolated value
//                 previous: 0,
//                 // current value
//                 current: 0,
//                 // amount to interpolate
//                 ease: 0.1,
//                 // the maximum value to translate the image is set in a CSS variable (--overflow)
//                 maxValue: parseInt(80, 10),
//                 // current value setter
//                 // the value of the translation will be:
//                 // when the item's top value (relative to the viewport) equals the window's height (items just came into the viewport) the translation = minimum value (- maximum value)
//                 // when the item's top value (relative to the viewport) equals "-item's height" (item just exited the viewport) the translation = maximum value
//                 setValue: () => {
//                     const maxValue = this.renderedStyles.innerTranslationY.maxValue;
//                     const minValue = -1 * maxValue;
//                     return Math.max(Math.min(MathUtils.map(this.props.top - docScroll, winsize.height, -1 * this.props.height, minValue, maxValue), maxValue), minValue)
//                 }
//             }
//         };
//         // set the initial values
//         this.update();
//         // use the IntersectionObserver API to check when the element is inside the viewport
//         // only then the element translation will be updated
//         this.observer = new IntersectionObserver((entries) => {
//             entries.forEach(entry => this.isVisible = entry.intersectionRatio > 0);
//         });
//         this.observer.observe(this.DOM.el);
//         // init/bind events
//         this.initEvents();
//     }
//     update() {
//         // gets the item's height and top (relative to the document)
//         this.getSize();
//         // sets the initial value (no interpolation)
//         for (const key in this.renderedStyles ) {
//             this.renderedStyles[key].current = this.renderedStyles[key].previous = this.renderedStyles[key].setValue();
//         }
//         // translate the image
//         this.layout();
//     }
//     getSize() {
//         const rect = this.DOM.el.getBoundingClientRect();
//         this.props = {
//             // item's height
//             height: rect.height,
//             // offset top relative to the document
//             top: docScroll + rect.top
//         }
//     }
//     initEvents() {
//         window.addEventListener('resize', () => this.resize());
//     }
//     resize() {
//         // on resize rest sizes and update the translation value
//         this.update();
//     }
//     render() {
//         // update the current and interpolated values
//         for (const key in this.renderedStyles ) {
//             this.renderedStyles[key].current = this.renderedStyles[key].setValue();
//             this.renderedStyles[key].previous = MathUtils.lerp(this.renderedStyles[key].previous, this.renderedStyles[key].current, this.renderedStyles[key].ease);
//         }
//         // and translates the image
//         this.layout();
//     }
//     layout() {
//         // translates the image
//         this.DOM.image.style.transform = `translate3d(0,${this.renderedStyles.innerTranslationY.previous}px,0)`;
//     }
// }
//     let items = [];
//     [...document.querySelectorAll(_img)].forEach(item => items.push(new Item(item)));
//     let render = function () {
//         // for every item
//         for (const item of items) {
//             // if the item is inside the viewport call it's render function
//             // this will update the item's inner image translation, based on the document scroll value and the item's position on the viewport
//             if ( item.isVisible ) {
//                 item.render();
//             }
//         }
//         requestAnimationFrame(() => render());
//     };
//         // start the render loop
//         requestAnimationFrame(() => render());
// Get the scroll position
// getPageYScroll();
// Initialize the Smooth Scrolling
// new SmoothScroll();;
// let _backToTop = el('#back-to-top');
// let _height = _navbar.height();
// let _focusPt = _height + 20;
// let _load, _scroll, _scrollEle = _body.get(0);

/*
// _scrollEle = window.document.scrollingElement || window.document.body || window.document.documentElement;
// _scrollEle = el(_scrollEle);
_navbar.click('.navbar-menu', e => {
    e.preventDefault();
    _navbar.toggleClass("navbar-show");
});

_backToTop.click(e => {
    e.preventDefault();
    anime({
        targets: _scrollEle,
        scrollTop: 0,
        duration: 500,
        easing: 'easeInOutQuad'
    });
});

let _actioncenter = el(".layer-action-center");
_global.scroll(_scroll = () => {
    _navbar.toggleClass("navbar-focus", (_global.scrollTop() + _height) >= _focusPt);
    _navbar.hasClass("navbar-show") && _navbar.removeClass("navbar-show");

    if ((_global.scrollTop() + _height) >= _focusPt * 2) {
        _actioncenter.show();
    } else { _actioncenter.hide(); }
});


_load = () => {
    let _next_layer_btn = el(".next-layer"), _next_layer;
    let _img = el(".load-img");
    let _main = el(".main");

    _scroll();

    var body = document.body,
        html = document.documentElement;

    var height = Math.max( body.scrollHeight, body.offsetHeight,
                        html.clientHeight, html.scrollHeight, html.offsetHeight );

    if (height <= window.innerHeight) {
        _actioncenter.show();
    }

    _img.each($img => {
        let img = el($img);
        let _core_img = img.find(".core-img").get(0);
        let _placeholder_img = img.find(".placeholder-img");

        if (_is.def(_core_img)) {
            if (_core_img.complete) {
                _placeholder_img.addClass("core-img-show");
            } else {
                _core_img.addEventListener("load", function () {
                    _placeholder_img.addClass("core-img-show");

                    setTimeout(function () { _placeholder_img.hide(); }, 3000);
                }, false);
            }
        }
    });

    _next_layer_btn.click((e, _el) => {
        e.preventDefault();
        _next_layer = el(_el).closest(".layer", _main).next(".layer");
        anime({
            targets: _scrollEle,
            scrollTop: el(_next_layer).offset().top - _height,
            duration: 500,
            easing: 'easeInOutQuad'
        });
    });

    // let options = {
    //     root: null,
    //     rootMargin: '0px',
    //     threshold: 0,
    //     // threshold: Array.from(Array(101), (_, x) => x / 100)
    // };

    // let observer = new IntersectionObserver(entries => {
    //     entries.forEach((entry, i) => {
    //         // if (entry.isIntersecting) {
    //         if (entry.intersectionRatio > 0) {
    //             // this.onScreen(entry)

    //             anime({
    //                 targets: entry.target,
    //                 translateY: 0,
    //                 opacity: 1,
    //                 duration: 1000,
    //                 easing: 'easeInOutExpo',
    //                 delay: i * 500,
    //                 begin() {
    //                     observer.unobserve(entry.target);
    //                 }
    //             });
    //         } else {
    //             // this.offScreen(entry)
    //         }
    //         // }
    //     });
    // }, options);

    // el(".layer").forEach(_el => {
    //     observer.observe(_el);
    // });
};

_load();
new swup({
    requestHeaders: {
        "X-Requested-With": "swup", // So we can tell request comes from swup
        "x-partial": "swup" // Request a partial html page
    },
    plugins: [new scrollPlugin({
        doScrollingRightAway: false,
        animateScroll: true,
        scrollFriction: 0.3,
        scrollAcceleration: 0.04,
    })] // new preload(),
})

// This event runs for every page view after initial load
.on('contentReplaced', _load);

// try {
} catch (e) {
let _img = [...document.getElementsByClassName("placeholder-img")];
let _navbar = [...document.getElementsByClassName("navbar")];
_navbar.forEach(function (nav) {
    nav.classList.add("navbar-focus");
});
_img.forEach(function (img) {
    img.classList.add("core-img-show");
});
} */
