// export const { assign, keys, values } = Object;
// export let { isArray, from, of } = Array;
const assign = Object.assign;
const keys = Object.keys;
const isArray = Array.isArray;

let _capital = val => val[0].toUpperCase() + val.slice(1); // Test the type of a value

let _is = (val, type) => typeof val === type; // Is Instance Of

let _isInst = (ctor, obj) => ctor instanceof obj;

let _type = type => {
  // Tweak of _is
  return val => _is(val, type);
};

assign(_is, {
  el: el => _isInst(el, Element) || _isInst(el, Document),

  arrlike(obj) {
    let len = _is(obj.length, "number") && obj.length;
    return len === 0 || len > 0 && len - 1 in obj;
  },

  num: val => !isNaN(val) && _type("number")(val),
  usable: v => !_is(v, "undefined") && v !== null,
  class: obj => obj && obj._method && obj._class,
  not: (type, ...args) => !_is[type](...args),
  doc: ctor => _isInst(ctor, Document),
  def: v => !_is(v, "undefined"),
  undef: _type("undefined"),
  win: v => v && v.window,
  bool: _type("boolean"),
  fn: _type("function"),
  str: _type("string"),
  obj: _type("object"),
  nul: v => v === null,
  inst: _isInst,
  arr: isArray,
  _type
});
/**
 * @param  {Function} fn
 * @param  {Array<any>} args
 * @param  {Object} ctxt
 */

let _fnval = (fn, args, ctxt) => {
  if (!_is.fn(fn) || keys(fn.prototype || {}).length > 0) {
    return fn;
  }

  return fn.apply(ctxt, args);
};

let _matches = (ele, sel) => {
  if (_is.undef(ele)) return;
  let matchSel = _is.el(sel) ? el => {
    var matches = [el],
        i = matches.length;

    while (--i >= 0 && matches[i] !== ele);

    return i > -1;
  } : ele.matches || ele.msMatchesSelector || ele.webkitMatchesSelector;
  if (matchSel) return matchSel.call(ele, sel);
}; // A more efficient `new` keyword that allows for arrays to be passed as arguments

let ele;
let tagRE = /^\s*<(\w+|!)[^>]*>/;
let tagExpandRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig;
let _qsa = (dom = document, sel) => {
  let classes;
  if (!_is.str(sel) && sel.length === 0) return [];

  if (/^(#?[\w-]+|\.[\w-.]+)$/.test(sel)) {
    switch (sel.charAt(0)) {
      case '#':
        return [dom.getElementById(sel.substr(1))];

      case '.':
        classes = sel.substr(1).replace(/\./g, ' ');
        return [...dom.getElementsByClassName(classes)];

      default:
        return [...dom.getElementsByTagName(sel)];
    }
  }

  return [...dom.querySelectorAll(sel)];
}; // Create an Element List from a HTML string

let _createElem = html => {
  let dom, container;
  container = document.createElement('div');
  container.innerHTML = '' + html.replace(tagExpandRE, "<$1></$2>");
  dom = [].slice.call(container.childNodes);
  dom.forEach(el => {
    container.removeChild(el);
  });
  return dom;
}; // Element selector

let _elem = (sel, ctxt) => {
  if (_is.str(sel)) {
    sel = sel.trim();

    if (tagRE.test(sel)) {
      return _createElem(sel);
    } else {
      return _qsa(ctxt, sel);
    }
  } else if (_is.inst(sel, ele)) {
    return sel;
  } else if (_is.arr(sel) || _is.inst(sel, NodeList)) {
    return [...sel].filter(item => _is.def(item));
  } else if (_is.obj(sel) || _is.el(sel)) {
    return [sel];
  } else if (_is.fn(sel)) {
    return _elem(sel());
  }

  return [];
}; // Element Object [Based on Zepto.js]

var ele$1 = ele = class {
  constructor(sel = '', ctxt) {
    this.sel = sel; // Selector

    this.ele = _elem(this.sel, ctxt); // Element

    for (let i = 0; i < this.ele.length; i++) {
      this[i] = this.ele[i];
    }

    this.length = this.ele.length;
  }

};

let el = (sel, ctxt) => {
  return _is.inst(sel, ele$1) && !_is.usable(ctxt) ? sel : new ele$1(sel, ctxt);
}; // Select specific element at an index of the ele object

let get = (_el, idx) => {
  _el = el(_el);
  return !_is.num(idx) ? [].slice.call(_el) : _el[idx >= 0 ? idx : idx + _el.length];
};

let toArray = val => _is.inst(val, ele$1) ? get(val) : val; // Convert ele objects to arrays

let _concat = function (...args) {
  [].map.call(args, val => toArray(val)); // Transform Elements to Arrays

  return [].concat(...args);
}; // Map objects and remove undefined/null values


let _map = (obj, fn, ctxt) => {
  let arr = [].map.call(obj, fn, ctxt).filter(item => _is.usable(item)); // Creates a flat Array of Objects

  return arr.length > 0 ? _concat(...arr) : arr;
}; // Added support for element mapping


let map = (_el, fn) => {
  _el = el(_el);
  return el(_map(_el, (el, i) => fn.call(el, el, i)));
}; // Functions the same way Array.forEach does
/* Similar to forEach, however, the context of the iterator is set and
   it allows the iterators return value to stop the iteration just like Array.every */

let each = (_el, fn) => {
  _el = el(_el);
  [].every.call(_el, function (el, idx) {
    return fn.call(el, el, idx) !== false;
  });
  return _el;
}; // Quickly filter nodes by a selector

let filter = (_el, sel) => {
  _el = el(_el);
  if (_is.undef(sel)) return _el;
  return el([].filter.call(_el, _is.fn(sel) ? sel : ele => _matches(ele, sel), _el));
}; // Check if the parent node contains the given DOM node. Returns false if both are the same node.

let _contains = (parent, node) => {
  if (parent.contains) return parent !== node && parent.contains(node);

  while (node && (node = node.parentNode)) if (node === parent) return true;

  return false;
}; // Find an element that matches a selector in a ele object


let find = (_el, sel) => {
  let result;
  _el = el(_el);
  if (!sel) result = el();else if (_is.obj(sel)) {
    result = filter(sel, el => {
      return [].some.call(_el, parent => _contains(parent, el));
    });
  } else if (_el.length === 1) {
    result = el(_qsa(get(_el, 0), sel));
  } else {
    result = map(_el, el => _qsa(el, sel));
  }
  return result;
}; // Check to see if a ele object has a certain element
// CSS properties that use unitless numbers

let _cssNumber = ["column-count", "columns", "font-weight", "line-height", "opacity", "z-index", "zoom"]; // Decide if the value deserves px at the

let _maybeAddPx = (name, val) => {
  return _is.num(+val) && !_cssNumber.includes(name) ? `${val}px` : val;
}; // Read or set CSS properties on DOM elements.


let style = (_el, ...args) => {
  let [prop, val] = args,
      css = '',
      key;

  if (args.length < 2) {
    let el = get(_el, 0);
    if (!el) return;

    if (_is.str(prop)) {
      return el.style[prop] || window.getComputedStyle(el, '').getPropertyValue(prop);
    } else if (_is.arr(prop)) {
      let props = {};
      let computedStyle = window.getComputedStyle(el, '');
      prop.forEach(_prop => {
        props[_prop] = el.style[_prop] || computedStyle.getPropertyValue(_prop);
      });
      return props;
    }
  }

  if (_is.str(prop)) {
    if (!val && val !== 0) {
      each(_el, el => {
        el.style.removeProperty(prop);
      });
    } else {
      css = prop + ":" + _maybeAddPx(prop, val);
    }
  } else {
    for (key in prop) {
      if (!prop[key] && prop[key] !== 0) {
        each(_el, el => {
          el.style.removeProperty(key);
        });
      } else {
        css += key + ':' + _maybeAddPx(key, prop[key]) + ';';
      }
    }
  }

  return each(_el, el => {
    el.style.cssText += ';' + css;
  });
}; // Method for creating size methods

let _size = sz => {
  let prop = _capital(sz);

  return (_el, value) => {
    let _offset,
        el = get(_el, 0);

    if (_is.undef(value)) {
      if (_is.win(el)) {
        return el[`inner${prop}`];
      } else if (_is.doc(el)) {
        return el.documentElement[`scroll${prop}`];
      } else {
        return (_offset = offset(_el)) && _offset[sz];
      }
    } else {
      return each(_el, ($el, idx) => {
        style($el, sz, _fnval(value, [idx, el[sz]()], $el));
      });
    }
  };
}; // Generate the `width` and `height` methods


let width = _size("width");
let height = _size("height"); // Show/hide an element

let _setAttr = (node, name, value) => value === null ? node.removeAttribute(name) : node.setAttribute(name, value); // Set the attribute of elements in the ele object


let attr = (_el, name, val) => {
  let result;
  _el = el(_el);

  if (_is.str(name) && _is.undef(val)) {
    result = _el.length && get(_el, 0).nodeType === 1 && get(_el, 0).getAttribute(name);
    return !_is.nul(result) ? result : undefined;
  } else {
    return each(_el, (el, idx) => {
      if (el.nodeType !== 1) return;

      if (_is.arr(name)) {
        for (let i in name) _setAttr(el, i, name[i]);
      } else {
        _setAttr(el, name, _fnval(val, [idx, el.getAttribute(name)], el));
      }
    });
  }
}; // Remove an attribute from all elements in the ele object

let _valfix = value => {
  let validTypes = /^true|false|null|undefined|\d+$/;

  let _fn = v => Function(`"use strict"; return ${v};`)();

  let objectType = /^[[{]([\s\S]+)?[\]}]$/;

  try {
    return validTypes.test(value) ? _fn(value) : objectType.test(value) ? JSON.parse(value.replace(/'/g, "\"")) : value;
  } catch (e) {
    return value;
  }
}; // Read or write data-* DOM attributes. Behaves like attr, but prepends data- to the attribute name.


let data = (_el, name, value) => {
  let attrName = `data-${name}`.toLowerCase();
  let data = _is.def(value) ? attr(_el, attrName, value) : attr(_el, attrName);
  return data !== null ? _valfix(data) : undefined;
};

let offset = (_el, coords) => {
  let obj;
  _el = el(_el);

  if (coords) {
    return each(_el, (el, idx) => {
      let $this = new ele$1(el);

      let _coords = _fnval(coords, [idx, offset($this)], el);

      let parentOffset = offset(offsetParent($this));
      let props = {
        top: _coords.top - parentOffset.top,
        left: _coords.left - parentOffset.left
      };
      if (style($this, 'position') === 'static') props.position = 'relative';
      style($this, props);
    });
  }

  if (!_el.length) return null;
  if (document.documentElement !== get(_el, 0) && !_contains(document.documentElement, get(_el, 0))) return {
    top: 0,
    left: 0
  };
  obj = get(_el, 0).getBoundingClientRect();
  return {
    left: obj.left + window.pageXOffset,
    top: obj.top + window.pageYOffset,
    width: Math.round(obj.width),
    height: Math.round(obj.height)
  };
}; // Get the position of an element in the ele object collection. When no element is given, returns position of the current element among its siblings. When an element is given, returns its position in the current collection. Returns -1 if not found.

let classcache = {}; // Class name RegExp

let _classRE = name => {
  return name in classcache ? classcache[name] : classcache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)');
}; // Get the class name for an element


let getclass = (node, value) => {
  let name = node.className || '';
  let svg = name && !_is.undef(name.baseVal);
  if (_is.undef(value)) return svg ? name.baseVal : name;
  svg ? name.baseVal = value : node.className = value;
}; // Check if any elements in the collection have the specified class.


let hasClass = (_el, name) => {
  if (!name) return false;
  return [].some.call(el(_el), el => {
    return _classRE(name).test(getclass(el));
  });
}; // Add class name to each of the elements in the collection. Multiple class names can be given in a space-separated string.

let addClass = (_el, name) => {
  _el = el(_el);
  if (!name) return _el;
  return each(_el, (el, idx) => {
    if (!('className' in el)) return;
    let classList = [],
        cls = getclass(el);

    _fnval(name, [idx, cls], el).split(/\s+/g).forEach(_name => {
      if (!hasClass(el, _name)) classList.push(_name);
    });

    classList.length && getclass(el, cls + (cls ? " " : "") + classList.join(" "));
  });
}; // Remove the specified class name from all elements in the collection. When the class name isn’t given, remove all class names. Multiple class names can be given in a space-separated string.

let removeClass = (_el, name) => {
  return each(_el, function (el, idx) {
    if (!('className' in el)) return;
    if (_is.undef(name)) return getclass(el, '');
    let classList = getclass(el);

    _fnval(name, [idx, classList], el).split(/\s+/g).forEach(_name => {
      classList = classList.replace(_classRE(_name), " ");
    });

    getclass(el, classList.trim());
  });
}; // Toggle given class names (space-separated) in each element in the collection. The class name is removed if present on an element; otherwise it’s added.

let toggleClass = (_el, name, when) => {
  _el = el(_el);
  if (!name) return _el;
  return each(_el, function (el, idx) {
    let $this = new ele$1(el);

    _fnval(name, [idx, getclass(el)], el).split(/\s+/g).forEach(_name => {
      (_is.undef(when) ? !hasClass($this, _name) : when) ? addClass($this, _name) : removeClass($this, _name);
    });
  });
}; // Find the first ancestor element that is positioned, meaning its CSS position value is "relative", "absolute" or "fixed".

let offsetParent = _el => {
  return map(_el, el => {
    let parent = el.offsetParent || document.body;

    while (parent && !/^(?:body|html)$/i.test(parent.nodeName) && style(parent, "position") === "static") {
      parent = parent.offsetParent;
    }

    return parent;
  });
}; // Get the position of the first element in the collection, relative to the offsetParent. This information is useful when absolutely positioning an element to appear aligned with another.

let scrollTop = (_el, val) => {
  _el = el(_el);
  if (!_el.length) return;
  let hasScroll = 'scrollTop' in get(_el, 0);
  if (_is.undef(val)) return get(_el, 0)[hasScroll ? "scrollTop" : "pageYOffset"];
  return each(_el, el => {
    hasScroll ? el.scrollTop = val : el.scrollTo(el.scrollX, val);
  });
}; // Gets or sets how many pixels were scrolled right so far on window or scrollable element on the page.

let scrollLeft = (_el, val) => {
  _el = el(_el);
  if (!_el.length) return;
  let hasScroll = 'scrollLeft' in get(_el, 0);
  if (_is.undef(val)) return get(_el, 0)[hasScroll ? "scrollLeft" : "pageXOffset"];
  return each(_el, el => {
    hasScroll ? el.scrollLeft = val : el.scrollTo(val, el.scrollY);
  });
}; // Animates the scrolling of the window in the y-axis

let scrollTo = (to, dur, ease) => {
  to = parseInt(to);
  dur = parseInt(dur);
  let start = window.pageYOffset,
      change = to - start,
      time = 0;

  let $ease = ease || ((time, start, change, length) => {
    if ((time /= length / 2) < 1) {
      return change / 2 * time * time + start;
    }

    return -change / 2 * (--time * (time - 2) - 1) + start;
  });

  let scroll,
      startTime = performance.now();
  return new Promise(resolve => {
    requestAnimationFrame(scroll = newTime => {
      time = newTime - startTime;
      window.scroll(0, $ease(time, start, change, dur));

      if (time < dur) {
        requestAnimationFrame(scroll);
      } else {
        window.scroll(0, to);
        resolve();
      }
    });
  });
}; // Test for passive support, based on [github.com/rafrex/detect-passive-events]

let passive = false,
    opts = {},
    noop = () => {};

try {
  opts = Object.defineProperty({}, "passive", {
    get: () => passive = {
      capture: false,
      passive: true
    }
  });
  window.addEventListener("PassiveEventTest", noop, opts);
  window.removeEventListener("PassiveEventsTest", noop, opts);
} catch (e) {} // Alias for the addEventListener; supports multiple elements


let on = ($el, evt, fn, opts) => {
  let $evt, _emit, useCapture;

  if (_is.undef(evt)) {
    return;
  } // If there is no event break


  if (_is.str(evt)) {
    evt = evt.split(/\s/g);
  }

  if (!_is.arr(evt) && !_is.obj(evt)) {
    evt = [evt];
  } // Set evt to an array


  return each($el, (_el, i) => {
    _emit = e => fn(e, _el, i); // Loop through the list of events


    keys(evt).forEach(key => {
      $evt = _is.obj(evt) && !_is.arr(evt) ? key : evt[key];

      if (/ready/.test($evt)) {
        if (!/in/.test(document.readyState)) {
          _emit({
            preventDefault: () => {}
          });
        } else if (document.addEventListener) {
          document.addEventListener('DOMContentLoaded', _emit);
        } else {
          // Support for IE
          document.attachEvent('onreadystatechange', e => {
            if (!/in/.test(document.readyState)) _emit(e);
          });
        }
      } else {
        useCapture = /blur|focus|touch/.test($evt);
        opts = _is.usable(opts) ? opts : $evt === "scroll" ? passive || {} : {
          useCapture
        };

        _el.addEventListener($evt, _emit, opts);
      }
    });
  });
}; // Alias for the removeEventListener; supports multiple elements

let off = ($el, evt, fn, opts) => {
  let $evt, _emit, useCapture;

  if (_is.undef(evt)) {
    return;
  } // If there is no event break


  if (_is.str(evt)) {
    evt = evt.split(/\s/g);
  }

  if (!_is.arr(evt) && !_is.obj(evt)) {
    evt = [evt];
  } // Set evt to an array


  return each($el, (_el, i) => {
    _emit = e => fn(e, _el, i); // Loop through the list of events


    keys(evt).forEach(key => {
      $evt = _is.obj(evt) && !_is.arr(evt) ? key : evt[key];
      useCapture = /blur|focus|touch/.test($evt); // opts = opts || $evt === "scroll" ? passive || {} : { useCapture };

      _el.removeEventListener($evt, _emit, opts);
    });
  });
}; // Generate shortforms for events eg. onclick(), onhover(), etc...

let {
  onready,
  onload,
  onblur,
  onfocus,
  onfocusin,
  onfocusout,
  onresize,
  onclick,
  onscroll,
  ondblclick,
  onmousedown,
  onmouseup,
  onmousemove,
  onmouseover,
  onmouseout,
  onmouseenter,
  onmouseleave,
  onchange,
  onselect,
  onsubmit,
  onkeydown,
  onkeypress,
  onkeyup,
  oncontextmenu,
  onorientationchange,
  ontouchstart,
  ontouchmove,
  ontouchend,
  ontouchcancel
} = `ready load blur focus focusin focusout resize click scroll dblclick mousedown
    mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit
    keydown keypress keyup contextmenu orientationchange touchstart touchmove touchend touchcancel`.split(/[\s\n]+/g).reduce((acc, name) => {
  // Handle event binding
  acc[`on${name}`] = (_el, ...args) => on(_el, name, ...args);

  return acc;
}, {
  onhover: (_el, fnOver, fnOut) => on(_el, {
    mouseenter: fnOver,
    mouseleave: fnOut || fnOver
  })
});

const _raf = window.requestAnimationFrame;
const _cancelRaf = window.cancelAnimationFrame;
const defaultOpts = {
  relativeToWrapper: false,
  mobileDevices: false,
  horizontal: false,
  vertical: true,
  wrapper: null,
  center: false,
  round: true,
  play: false,
  speed: -2
};
class Parallax {
  constructor($el = '.effect-parallax', opts) {
    const {
      wrapper
    } = opts;
    this.opts = assign({}, defaultOpts, opts);
    this.elems = el($el); // Has a wrapper and it exists

    _is.usable(wrapper) && (this.opts.wrapper = el(wrapper));
    this.isPlaying = this.opts.play;
    this.screenX = 0;
    this.screenY = 0;
    this.posX = 0;
    this.posY = 0;
    this.list = [];
    this.loop = null;
    if (this.isPlaying) this.start();
  }

  getPos(percentx, percenty, speed) {
    const {
      round
    } = this.opts;
    let valuex = speed * (100 * (1 - percentx));
    let valuey = speed * (100 * (1 - percenty));
    return {
      x: round ? Math.round(valuex) : Math.round(valuex * 100) / 100,
      y: round ? Math.round(valuey) : Math.round(valuey * 100) / 100
    };
  }

  getTransform(el) {
    // ~~Store non-translate3d transforms~~
    // Store inline styles and extract transforms
    let style = el.style.cssText; // Check if there's an inline styled transform

    let result = /transform\s*:/i.exec(style);

    if (result) {
      // Get the index of the transform
      let {
        index
      } = result; // Trim the style to the transform point and get the following semi-colon index

      let transform = style.slice(index);
      let delimiter = transform.includes(";") ? transform.indexOf(';') : undefined; // Remove "transform" string and save the attribute

      return " " + transform.slice(11, delimiter).replace(/\s/g, '');
    }

    return '';
  }

  getData($el) {
    const {
      wrapper,
      vertical,
      horizontal,
      speed,
      relativeToWrapper,
      center
    } = this.opts;
    const dataPercentage = data($el, 'parallax-percentage');
    const dataZindex = data($el, 'parallax-zindex') || 0;
    const dataSpeed = data($el, 'parallax-speed');
    const dataMin = data($el, 'parallax-min');
    const dataMax = data($el, 'parallax-max');
    let x_scrll = scrollLeft(window);
    let y_scrll = scrollTop(window);
    let wrapperY = wrapper ? scrollTop(wrapper) : y_scrll;
    if (relativeToWrapper) wrapperY = y_scrll - offset(wrapper).top;
    let posY = vertical ? dataPercentage || center ? wrapperY : 0 : 0;
    let posX = horizontal ? dataPercentage || center ? wrapper ? scrollLeft(wrapper) : x_scrll : 0 : 0;
    let {
      top,
      left
    } = $el.getBoundingClientRect();
    let blockTop = posY + top,
        blockLeft = posX + left;
    let blockW = $el.clientWidth || $el.offsetWidth || $el.scrollWidth;
    let blockH = $el.clientHeight || $el.offsetHeight || $el.scrollHeight;
    this.screenX = width(window);
    this.screenY = height(window);
    let percentx = dataPercentage ? dataPercentage : (posX - blockLeft + this.screenX) / (blockW + this.screenX);
    let percenty = dataPercentage ? dataPercentage : (posY - blockTop + this.screenY) / (blockH + this.screenY);

    if (center) {
      percentx = 0.5;
      percenty = 0.5;
    } // Optional individual block speed as data attr, otherwise global speed


    let $speed = dataSpeed ? dataSpeed : speed;
    let $bases = this.getPos(percentx, percenty, $speed);
    let $transform = this.getTransform($el);
    return {
      style: $el.style.cssText,
      transform: $transform,
      zindex: dataZindex,
      baseX: $bases.x,
      baseY: $bases.y,
      left: blockLeft,
      height: blockH,
      width: blockW,
      top: blockTop,
      speed: speed,
      min: dataMin,
      max: dataMax
    };
  }

  setPos() {
    const {
      wrapper,
      vertical,
      horizontal,
      relativeToWrapper
    } = this.opts;
    let oldX = this.posX,
        oldY = this.posY;
    let x_scrll = scrollLeft(window);
    let y_scrll = scrollTop(window);
    this.posX = wrapper ? scrollLeft(wrapper) : x_scrll;
    this.posY = wrapper ? scrollTop(wrapper) : y_scrll;
    if (relativeToWrapper) this.posY = y_scrll - offset(wrapper).top;
    return oldY !== this.posY && vertical || oldX !== this.posX && horizontal;
  }

  hasPosChanged() {
    const {
      wrapper,
      vertical,
      horizontal,
      relativeToWrapper
    } = this.opts;
    let oldX = this.posX,
        oldY = this.posY;
    let x_scrll = scrollLeft(window);
    let y_scrll = scrollTop(window);
    let posX = wrapper ? scrollLeft(wrapper) : x_scrll;
    let posY = wrapper ? scrollTop(wrapper) : y_scrll;
    if (relativeToWrapper) posY = y_scrll - offset(wrapper).top;
    return oldY !== posY && vertical || oldX !== posX && horizontal;
  }

  animate() {
    const {
      vertical,
      horizontal
    } = this.opts;
    each(this.elems, ($el, i) => {
      let {
        top,
        left,
        height,
        width,
        speed,
        baseY,
        baseX,
        min,
        max,
        zindex,
        transform
      } = this.list[i];
      let percentx = (this.posX - left + this.screenX) / (width + this.screenX);
      let percenty = (this.posY - top + this.screenY) / (height + this.screenY); // Subtracting initialize value, so element stays in same spot as HTML

      let pos = this.getPos(percentx, percenty, speed);

      let _posX = pos.x - baseX;

      let _posY = pos.y - baseY; // Check if a min limit is defined


      if (!_is.nul(min)) {
        if (horizontal) _posX = _posX <= min ? min : _posX;
        if (vertical) _posY = _posY <= min ? min : _posY;
      } // Check if a max limit is defined


      if (!_is.nul(max)) {
        if (horizontal) _posX = _posX >= max ? max : _posX;
        if (vertical) _posY = _posY >= max ? max : _posY;
      } // Move that element
      // (Set the new translation and append initial inline transforms.)


      style($el, "transform", `translate3d(${horizontal ? _posX : '0'}px, ${vertical ? _posY : '0'}px,${zindex}px) ${transform}`);
    });
    return this; // self.options.callback(positions);
  }

  applyEvents() {
    const {
      wrapper
    } = this.opts;
    this.loop = null;
    on(window, 'resize orientationchange', this.removeEvents.bind(this));
    on(window, 'scroll', this.removeEvents.bind(this));
    on(wrapper ? wrapper : window, 'scroll', this.removeEvents.bind(this));
    on(wrapper ? wrapper : document, 'touchmove', this.removeEvents.bind(this)); // Don't animate until we get a position updating event
    // window.addEventListener('resize', this.deferredUpdate.bind(this));
    // window.addEventListener('orientationchange', this.deferredUpdate.bind(this));
    // (wrapper ? wrapper : window).addEventListener('scroll', this.deferredUpdate.bind(this), supportsPassive ? { passive: true } : false);
    // (wrapper ? wrapper : document).addEventListener('touchmove', this.deferredUpdate.bind(this), supportsPassive ? { passive: true } : false);
  }

  removeEvents() {
    const {
      wrapper
    } = this.opts;
    off(window, 'resize orientationchange', this.removeEvents.bind(this));
    off(window, 'scroll', this.removeEvents.bind(this));
    off(wrapper ? wrapper : window, 'scroll', this.removeEvents.bind(this));
    off(wrapper ? wrapper : document, 'touchmove', this.removeEvents.bind(this)); // window.removeEventListener('resize', this.deferredUpdate.bind(this));
    // window.removeEventListener('orientationchange', this.deferredUpdate.bind(this));
    // (wrapper ? wrapper : window).removeEventListener('scroll', this.deferredUpdate.bind(this));
    // (wrapper ? wrapper : document).removeEventListener('touchmove', this.deferredUpdate.bind(this));
    // Loop again

    this.loop = _raf(this.update.bind(this));
  }

  play() {
    this.isPlaying = true;
    return this;
  }

  pause() {
    this.isPlaying = false;
    return this;
  } // Loop


  update() {
    if (this.setPos() && this.isPlaying) {
      this.animate(); // Loop again

      this.loop = _raf(this.update.bind(this));
    } else {
      this.applyEvents();
    }
  }

  start() {
    this.list.forEach((block, i) => {
      this.elems[i].style.cssText = block.style;
    }, this);
    this.list = [];
    this.screenX = width(window);
    this.screenY = height(window);
    this.setPos();
    each(this.elems, ($el, i) => {
      this.list[i] = this.getData($el);
    });
    this.animate(); // If paused, unpause and set listener for window resizing events

    if (!this.isPlaying && this.mobileDevices) {
      on(window, 'resize', this.start.bind(this));
      this.play(); // Start the loop

      this.update();
    }
  }

  destroy() {
    each(this.elems, ($el, i) => {
      this.elems[i].style.cssText = this.list[i].style;
    }); // Remove resize event listener if not pause, and pause

    if (this.isPlaying) {
      off(window, 'resize', this.start.bind(this));
      this.pause();
    } // Clear the animation loop to prevent possible memory leak


    _cancelRaf(this.loop);

    this.loop = null;
  } // Allow to recalculate the initial values whenever we want


  get refresh() {
    return this.start;
  }

}
let parallax = (...args) => new Parallax(...args);

// import swup from "swup";
let _img = ".load-img";
let _navbar = '.navbar';
let _hero = ".layer-hero";
let _menu = '.navbar-menu';
let _backUp = '.back-to-top';
let _actioncenter = ".layer-action-center";
let _scrolldown = '.layer-hero-scroll-down';

let _height = height(_navbar);

let _focusPt = _height + 10; //  touchstart


on(_menu, "click", () => {
  toggleClass(_navbar, "navbar-show");
}, false);
off(_menu, "click", () => {
  toggleClass(_navbar, "navbar-show");
}, false); // _menu
// touchstart

on(_backUp, "click", () => {
  scrollTo("0px", "700s");
}); // touchstart

on(_scrolldown, "click", () => {
  scrollTo(height(_hero) + _focusPt, "700s");
});
on(window, 'scroll', () => {
  toggleClass(_navbar, "navbar-focus", scrollTop(window) >= 5);
  hasClass(_navbar, "navbar-show") && removeClass(_navbar, "navbar-show");
  toggleClass(_actioncenter, "layer-action-center-show", scrollTop(window) > _focusPt * 2);
  toggleClass(_actioncenter, "layer-action-center-hide", scrollTop(window) <= _focusPt * 2);
});
each(_img, $img => {
  let _core_img = get(find($img, ".core-img"), 0);

  let _placeholder_img = find($img, ".placeholder-img");

  if (_is.def(_core_img)) {
    if (_core_img.complete) {
      addClass(_placeholder_img, "core-img-show");
    } else {
      _core_img.addEventListener("load", function () {
        addClass(_placeholder_img, "core-img-show");
      }, false);
    }
  }
});
/*
let observer = new IntersectionObserver(entries => {
    entries.forEach((entry, i) => isVisible[i] = entry.intersectionRatio > 0);
}, {
  rootMargin: '0px',
  threshold: 1.0
});
*/

parallax('.load-img', {
  play: true,
  speed: -6,
  center: true,
  round: true
}); // each('.load-img', ($el, i) => {
//     if (inWin($el) && width(window) >= 600) {
//         images[i].refresh();
//     } else { images[i].destroy(); }
//     i == 1 && console.log("Top: " + $el.getBoundingClientRect().top + " < Bottom: " + (height(window)));
//     _log("In Window: " + inWin($el));
// });
// new Rellax('.load-img', {
//     speed: width(window) > 600 ? 2 : 0,
//     center: false,
//     round: false,
//     vertical: true,
//     horizontal: false
// })
// // helper functions
// const MathUtils = {
//     // map number x from range [a, b] to [c, d]
//     map: (x, a, b, c, d) => (x - a) * (d - c) / (b - a) + c,
//     // linear interpolation
//     lerp: (a, b, n) => (1 - n) * a + n * b
// };
// // body element
// const body = document.body;
// // calculate the viewport size
// let winsize;
// const calcWinsize = () => winsize = {width: window.innerWidth, height: window.innerHeight};
// calcWinsize();
// // and recalculate on resize
// window.addEventListener('resize', calcWinsize);
// // scroll position and update function
// let docScroll;
// const getPageYScroll = () => docScroll = window.pageYOffset || document.documentElement.scrollTop;
// window.addEventListener('scroll', getPageYScroll);
// // Item
// class Item {
//     constructor(el) {
//         // the .item element
//         this.DOM = {el: el};
//         // the inner image
//         this.DOM.image = this.DOM.el.querySelector('.core-img');
//         this.renderedStyles = {
//             // here we define which property will change as we scroll the page and the items is inside the viewport
//             // in this case we will be translating the image on the y-axis
//             // we interpolate between the previous and current value to achieve a smooth effect
//             innerTranslationY: {
//                 // interpolated value
//                 previous: 0,
//                 // current value
//                 current: 0,
//                 // amount to interpolate
//                 ease: 0.1,
//                 // the maximum value to translate the image is set in a CSS variable (--overflow)
//                 maxValue: parseInt(80, 10),
//                 // current value setter
//                 // the value of the translation will be:
//                 // when the item's top value (relative to the viewport) equals the window's height (items just came into the viewport) the translation = minimum value (- maximum value)
//                 // when the item's top value (relative to the viewport) equals "-item's height" (item just exited the viewport) the translation = maximum value
//                 setValue: () => {
//                     const maxValue = this.renderedStyles.innerTranslationY.maxValue;
//                     const minValue = -1 * maxValue;
//                     return Math.max(Math.min(MathUtils.map(this.props.top - docScroll, winsize.height, -1 * this.props.height, minValue, maxValue), maxValue), minValue)
//                 }
//             }
//         };
//         // set the initial values
//         this.update();
//         // use the IntersectionObserver API to check when the element is inside the viewport
//         // only then the element translation will be updated
//         this.observer = new IntersectionObserver((entries) => {
//             entries.forEach(entry => this.isVisible = entry.intersectionRatio > 0);
//         });
//         this.observer.observe(this.DOM.el);
//         // init/bind events
//         this.initEvents();
//     }
//     update() {
//         // gets the item's height and top (relative to the document)
//         this.getSize();
//         // sets the initial value (no interpolation)
//         for (const key in this.renderedStyles ) {
//             this.renderedStyles[key].current = this.renderedStyles[key].previous = this.renderedStyles[key].setValue();
//         }
//         // translate the image
//         this.layout();
//     }
//     getSize() {
//         const rect = this.DOM.el.getBoundingClientRect();
//         this.props = {
//             // item's height
//             height: rect.height,
//             // offset top relative to the document
//             top: docScroll + rect.top
//         }
//     }
//     initEvents() {
//         window.addEventListener('resize', () => this.resize());
//     }
//     resize() {
//         // on resize rest sizes and update the translation value
//         this.update();
//     }
//     render() {
//         // update the current and interpolated values
//         for (const key in this.renderedStyles ) {
//             this.renderedStyles[key].current = this.renderedStyles[key].setValue();
//             this.renderedStyles[key].previous = MathUtils.lerp(this.renderedStyles[key].previous, this.renderedStyles[key].current, this.renderedStyles[key].ease);
//         }
//         // and translates the image
//         this.layout();
//     }
//     layout() {
//         // translates the image
//         this.DOM.image.style.transform = `translate3d(0,${this.renderedStyles.innerTranslationY.previous}px,0)`;
//     }
// }
//     let items = [];
//     [...document.querySelectorAll(_img)].forEach(item => items.push(new Item(item)));
//     let render = function () {
//         // for every item
//         for (const item of items) {
//             // if the item is inside the viewport call it's render function
//             // this will update the item's inner image translation, based on the document scroll value and the item's position on the viewport
//             if ( item.isVisible ) {
//                 item.render();
//             }
//         }
//         requestAnimationFrame(() => render());
//     };
//         // start the render loop
//         requestAnimationFrame(() => render());
// Get the scroll position
// getPageYScroll();
// Initialize the Smooth Scrolling
// new SmoothScroll();;
// let _backToTop = el('#back-to-top');
// let _height = _navbar.height();
// let _focusPt = _height + 20;
// let _load, _scroll, _scrollEle = _body.get(0);

/*
// _scrollEle = window.document.scrollingElement || window.document.body || window.document.documentElement;
// _scrollEle = el(_scrollEle);
_navbar.click('.navbar-menu', e => {
    e.preventDefault();
    _navbar.toggleClass("navbar-show");
});

_backToTop.click(e => {
    e.preventDefault();
    anime({
        targets: _scrollEle,
        scrollTop: 0,
        duration: 500,
        easing: 'easeInOutQuad'
    });
});

let _actioncenter = el(".layer-action-center");
window.scroll(_scroll = () => {
    _navbar.toggleClass("navbar-focus", (window.scrollTop() + _height) >= _focusPt);
    _navbar.hasClass("navbar-show") && _navbar.removeClass("navbar-show");

    if ((window.scrollTop() + _height) >= _focusPt * 2) {
        _actioncenter.show();
    } else { _actioncenter.hide(); }
});


_load = () => {
    let _next_layer_btn = el(".next-layer"), _next_layer;
    let _img = el(".load-img");
    let _main = el(".main");

    _scroll();

    var body = document.body,
        html = document.documentElement;

    var height = Math.max( body.scrollHeight, body.offsetHeight,
                        html.clientHeight, html.scrollHeight, html.offsetHeight );

    if (height <= window.innerHeight) {
        _actioncenter.show();
    }

    _img.each($img => {
        let img = el($img);
        let _core_img = img.find(".core-img").get(0);
        let _placeholder_img = img.find(".placeholder-img");

        if (_is.def(_core_img)) {
            if (_core_img.complete) {
                _placeholder_img.addClass("core-img-show");
            } else {
                _core_img.addEventListener("load", function () {
                    _placeholder_img.addClass("core-img-show");

                    setTimeout(function () { _placeholder_img.hide(); }, 3000);
                }, false);
            }
        }
    });

    _next_layer_btn.click((e, _el) => {
        e.preventDefault();
        _next_layer = el(_el).closest(".layer", _main).next(".layer");
        anime({
            targets: _scrollEle,
            scrollTop: el(_next_layer).offset().top - _height,
            duration: 500,
            easing: 'easeInOutQuad'
        });
    });

    // let options = {
    //     root: null,
    //     rootMargin: '0px',
    //     threshold: 0,
    //     // threshold: Array.from(Array(101), (_, x) => x / 100)
    // };

    // let observer = new IntersectionObserver(entries => {
    //     entries.forEach((entry, i) => {
    //         // if (entry.isIntersecting) {
    //         if (entry.intersectionRatio > 0) {
    //             // this.onScreen(entry)

    //             anime({
    //                 targets: entry.target,
    //                 translateY: 0,
    //                 opacity: 1,
    //                 duration: 1000,
    //                 easing: 'easeInOutExpo',
    //                 delay: i * 500,
    //                 begin() {
    //                     observer.unobserve(entry.target);
    //                 }
    //             });
    //         } else {
    //             // this.offScreen(entry)
    //         }
    //         // }
    //     });
    // }, options);

    // el(".layer").forEach(_el => {
    //     observer.observe(_el);
    // });
};

_load();
new swup({
    requestHeaders: {
        "X-Requested-With": "swup", // So we can tell request comes from swup
        "x-partial": "swup" // Request a partial html page
    },
    plugins: [new scrollPlugin({
        doScrollingRightAway: false,
        animateScroll: true,
        scrollFriction: 0.3,
        scrollAcceleration: 0.04,
    })] // new preload(),
})

// This event runs for every page view after initial load
.on('contentReplaced', _load);

// try {
} catch (e) {
let _img = [...document.getElementsByClassName("placeholder-img")];
let _navbar = [...document.getElementsByClassName("navbar")];
_navbar.forEach(function (nav) {
    nav.classList.add("navbar-focus");
});
_img.forEach(function (img) {
    img.classList.add("core-img-show");
});
} */
